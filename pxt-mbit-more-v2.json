{"MbitMore.cpp":"#include \"pxt.h\"\n\n#include \"MicroBit.h\"\n#include \"MicroBitConfig.h\"\n\n#include \"MbitMoreCommon.h\"\n\n#define UPDATE_PERIOD 19\n#define NOTIFY_PERIOD 101\n\n#if MICROBIT_CODAL\n#include \"MbitMoreService.h\"\n#else // NOT MICROBIT_CODAL\n#include \"MbitMoreServiceDAL.h\"\nusing MbitMoreService = MbitMoreServiceDAL;\n#endif // NOT MICROBIT_CODAL\n\n//% color=#FF9900 weight=95 icon=\"\\uf1b0\"\nnamespace MbitMore {\n  MbitMoreService *_pService = NULL;\n#if MICROBIT_CODAL\n#else // NOT MICROBIT_CODAL\n  int dummyDataLabelID = 0;\n#endif // NOT MICROBIT_CODAL\n\n  void update() {\n    while (NULL != _pService) {\n      _pService->update();\n      fiber_sleep(UPDATE_PERIOD);\n    }\n  }\n\n  void notifyScratch() {\n    while (NULL != _pService) {\n      // notyfy data to Scratch\n      _pService->notify();\n      fiber_sleep(NOTIFY_PERIOD);\n    }\n  }\n\n  /**\n   * @brief Start Microbit More service.\n   * \n   */\n  //%\n  void startMbitMoreService() {\n    if (NULL != _pService)\n      return;\n\n    _pService = new MbitMoreService();\n\n    create_fiber(update);\n    // create_fiber(notifyScratch);\n  }\n\n  /**\n   * @brief Register a label in waiting data list and return an ID for the label.\n   * This starts Microbit More service if it was not available.\n   * \n   * @param dataLabel label to register\n   * @param dataType type of the data to be received\n   * @return int ID for the label\n   */\n  //%\n  int call_registerWaitingDataLabel(String dataLabel, MbitMoreDataContentType dataType) {\n#if MICROBIT_CODAL\n    if (NULL == _pService)\n      startMbitMoreService();\n\n    int labelID = _pService->registerWaitingDataLabel(MSTR(dataLabel), dataType);\n    return labelID;\n#else // NOT MICROBIT_CODAL\n    return ++dummyDataLabelID; // dummy\n#endif // NOT MICROBIT_CODAL\n  }\n\n  /**\n   * @brief Get number which was received with the label.\n   * \n   * @param labelID ID in registered labels\n   * @return float received data with the label\n   */\n  //%\n  float call_dataContentAsNumber(int labelID) {\n#if MICROBIT_CODAL\n    return _pService->dataContentAsNumber(labelID);\n#else // NOT MICROBIT_CODAL\n    return 0.0; // dummy\n#endif // NOT MICROBIT_CODAL\n  }\n\n  /**\n   * @brief Get text which was received with the label.\n   * \n   * @param labelID ID in registered labels\n   * @return String received data with the label\n   */\n  //%\n  String call_dataContentAsText(int labelID) {\n#if MICROBIT_CODAL\n    return PSTR(_pService->dataContentAsText(labelID));\n#else // NOT MICROBIT_CODAL\n    return String(\"\"); // dummy\n#endif // NOT MICROBIT_CODAL\n  }\n\n  /**\n   * @brief Send a float with labele to Scratch.\n   * Do nothing if Scratch was not connected.\n   * \n   * @param dataLabel - label of the data\n   * @param dataContent - content of the data\n   */\n  //%\n  void call_sendNumberWithLabel(String dataLabel, float dataContent) {\n#if MICROBIT_CODAL\n    if (NULL == _pService)\n      return;\n\n    _pService->sendNumberWithLabel(MSTR(dataLabel), dataContent);\n#endif // MICROBIT_CODAL\n  }\n\n  /**\n   * @brief Send a text with label to Scratch.\n   * Do nothing if Scratch was not connected.\n   * \n   * @param dataLabel - label of the data\n   * @param dataContent - content of the data\n   */\n  //%\n  void call_sendTextWithLabel(String dataLabel, String dataContent) {\n#if MICROBIT_CODAL\n    if (NULL == _pService)\n      return;\n\n    _pService->sendTextWithLabel(MSTR(dataLabel), MSTR(dataContent));\n#endif // MICROBIT_CODAL\n  }\n\n} // namespace MbitMore\n","MbitMore.ts":"namespace MbitMore {\n  const MBIT_MORE_DATA_RECEIVED = 8000;\n\n  /**\n  * Starts BLE services for Scratch Microbit-More extension.\n  */\n  //% blockId=MbitMore_startMbitMoreService block=\"start Microbit-More service\"\n  //% shim=MbitMore::startMbitMoreService\n  export function startService(): void {\n    console.log(\"Microbit-More started\");\n  }\n\n  /**\n  * Register a label and return its ID.\n  */\n  //% shim=MbitMore::call_registerWaitingDataLabel\n  export function registerWaitingDataLabel(label: string, type: MbitMoreDataContentType): number {\n    console.log(\"Microbit-More registered label: \" + label);\n    return 1; // dummy for sim\n  }\n\n  /**\n   * Read received data as a number\n   */\n  //% shim=MbitMore::call_dataContentAsNumber\n  export function dataContentAsNumber(labelID: number): number {\n    return 0.0; // dummy for sim\n  }\n\n  /**\n   * Read received data as a text\n   */\n  //% shim=MbitMore::call_dataContentAsText\n  export function dataContentAsText(labelID: number): string {\n    return \"text\"; // dummy for sim\n  }\n\n  /**\n   * Run blocks with data when a number data with the label is received.\n   * @param label - label of the data\n   * @param handler - blocks to run\n   */\n  //% blockId=MbitMore_onReceivedNumberWithLabel\n  //% block=\"on number $numberData with label $label\"\n  //% label.defl=\"label-01\"\n  //% draggableParameters\n  export function onReceivedNumberWithLabel(label: string, handler: (numberData: number) => void) {\n    let labelID = MbitMore.registerWaitingDataLabel(label, MbitMoreDataContentType.MM_DATA_NUMBER);\n    if (0 === labelID) {\n      throw \"max waiting label counts exceed\";\n    }\n    control.onEvent(MBIT_MORE_DATA_RECEIVED, labelID, function () {\n      handler(MbitMore.dataContentAsNumber(labelID));\n      return;\n    });\n  }\n\n  /**\n   * Run blocks with data when a text data with the label is received.\n   * @param label - label of the data\n   * @param handler - blocks to run\n   */\n  //% blockId=MbitMore_onReceivedTextWithLabel\n  //% block=\"on text $textData with label $label\"\n  //% label.defl=\"label-01\"\n  //% draggableParameters\n  export function onReceivedTextWithLabel(label: string, handler: (textData: string) => void) {\n    let labelID = MbitMore.registerWaitingDataLabel(label, MbitMoreDataContentType.MM_DATA_TEXT);\n    if (0 === labelID) {\n      throw \"max waiting label counts exceed\";\n    }\n    control.onEvent(MBIT_MORE_DATA_RECEIVED, labelID, function () {\n      handler(MbitMore.dataContentAsText(labelID));\n      return;\n    });\n  }\n\n  /**\n   * Send number with label\n   * @param label lavel of the data \n   * @param data number value to send\n   */\n  //% blockId=MbitMore_sendNumberWithLabel\n  //% block=\"send number $numberData with label $label\"\n  //% shim=MbitMore::call_sendNumberWithLabel\n  //% label.defl=\"label-01\"\n  //% numberData.defl=0.0\n  export function sendNumberWithLabel(label: string, numberData: number): void {\n    console.log(\"Microbit-More send a number: \" + label + \" = \" + numberData);\n  }\n\n  /**\n   * Send text with label\n   * @param label lavel of the data\n   * @param data text to send\n   */\n  //% blockId=MbitMore_sendTextWithLabel\n  //% block=\"send text $textData with label $label\"\n  //% shim=MbitMore::call_sendTextWithLabel\n  //% label.defl=\"label-01\"\n  //% textData.defl=\"text\"\n  export function sendTextWithLabel(label: string, textData: string): void {\n    console.log(\"Microbit-More send a text: \" + label + \" = \" + textData);\n  }\n\n} // namespace MbitMore","MbitMoreCommon.h":"#ifndef MBIT_MORE_COMMON_H\n#define MBIT_MORE_COMMON_H\n\n#include \"pxt.h\"\n\n#if MICROBIT_CODAL\n#define MBIT_MORE_USE_SERIAL 1\n#else // MICROBIT_CODAL\n#define MBIT_MORE_USE_SERIAL 0 // v1 has not enough memory space\n#endif // MICROBIT_CODAL\n\n#define MBIT_MORE_DATA_RECEIVED 8000\n\n/**\n * Data type of content.\n */\nenum MbitMoreDataContentType\n{\n  //% block=\"number\"\n  MM_DATA_NUMBER = 1,\n  //% block=\"text\"\n  MM_DATA_TEXT = 2,\n};\n\n#define MM_CH_BUFFER_SIZE_COMMAND 20\n#define MM_CH_BUFFER_SIZE_NOTIFY 20\n#define MM_CH_BUFFER_SIZE_STATE 7\n#define MM_CH_BUFFER_SIZE_MOTION 18\n#define MM_CH_BUFFER_SIZE_ANALOG_IN 2\n\nenum MbitMoreCommand // 3 bits (0x00..0x07)\n{\n  CMD_CONFIG = 0x00,\n  CMD_PIN = 0x01,\n  CMD_DISPLAY = 0x02,\n  CMD_AUDIO = 0x03,\n  CMD_DATA = 0x04,\n};\n\nenum MbitMorePinCommand\n{\n  SET_OUTPUT = 0x01,\n  SET_PWM = 0x02,\n  SET_SERVO = 0x03,\n  SET_PULL = 0x04,\n  SET_EVENT = 0x05,\n};\n\nenum MbitMoreDisplayCommand\n{\n  CLEAR = 0x00,\n  TEXT = 0x01,\n  PIXELS_0 = 0x02,\n  PIXELS_1 = 0x03,\n};\n\n/**\n * @brief Enum for write mode of display pixels.\n */\nenum MbitMoreDisplayWriteMode\n{\n  LAYER = 0,\n  OVER_WRITE = 1\n};\n\nenum MbitMorePullMode\n{\n  None = 0,\n  Down = 1,\n  Up = 2,\n};\n\nenum MbitMoreDataFormat\n{\n  CONFIG = 0x10, // not used at this version\n  PIN_EVENT = 0x11,\n  ACTION_EVENT = 0x12,\n  DATA_NUMBER = 0x13,\n  DATA_TEXT = 0x14\n};\n\nenum MbitMoreActionEvent\n{\n  BUTTON = 0x01,\n  GESTURE = 0x02\n};\n\nenum MbitMoreButtonEvent\n{\n  DOWN = 1,\n  UP = 2,\n  CLICK = 3,\n  LONG_CLICK = 4,\n  HOLD = 5,\n  DOUBLE_CLICK = 6\n};\n\nenum MbitMoreGestureEvent\n{\n  TILT_UP = 1,\n  TILT_DOWN = 2,\n  TILT_LEFT = 3,\n  TILT_RIGHT = 4,\n  FACE_UP = 5,\n  FACE_DOWN = 6,\n  FREEFALL = 7,\n  G3 = 8,\n  G6 = 9,\n  G8 = 10,\n  SHAKE = 11\n};\n\nenum MbitMorePinEventType\n{\n  NONE = 0,\n  ON_EDGE = 1,\n  ON_PULSE = 2,\n  ON_TOUCH = 3\n};\n\nenum MbitMorePinEvent\n{\n  RISE = 2,\n  FALL = 3,\n  PULSE_HIGH = 4,\n  PULSE_LOW = 5\n};\n\n/**\n * @brief Enum for sub-command about configurations.\n * \n */\nenum MbitMoreConfig\n{\n  MIC = 0x01, // microphone\n  TOUCH = 0x02\n};\n\n/**\n * @brief Enum for sub-commands about audio.\n * \n */\nenum MbitMoreAudioCommand\n{\n  STOP_TONE = 0x00,\n  PLAY_TONE = 0x01,\n};\n\n#endif // MBIT_MORE_COMMON_H\n","MbitMoreDevice.cpp":"\n#include \"pxt.h\"\n\n#include \"MicroBit.h\"\n#include \"MicroBitConfig.h\"\n\n#if MICROBIT_CODAL\n// microphone sound level\n#include \"LevelDetector.h\"\n#include \"LevelDetectorSPL.h\"\n\n#define MICROPHONE_MIN 52.0f\n#define MICROPHONE_MAX 120.0f\n\nnamespace pxt {\n  codal::LevelDetectorSPL *getMicrophoneLevel();\n} // namespace pxt\n\nint getMicLevel() {\n  auto level = pxt::getMicrophoneLevel();\n  if (NULL == level)\n    return 0;\n  const int micValue = level->getValue();\n  const int scaled = max(MICROPHONE_MIN, min(micValue, MICROPHONE_MAX)) - MICROPHONE_MIN;\n  return min(0xff, scaled * 0xff / (MICROPHONE_MAX - MICROPHONE_MIN));\n}\n#endif // MICROBIT_CODAL\n\n/**\n * @brief Compute average value for the int array.\n *\n * @param data Array to compute average.\n * @param dataSize Length of the array.\n * @return average value.\n */\nint average(int *data, int dataSize) {\n  int sum = 0;\n  int i;\n  for (i = 0; i < dataSize - 1; i++) {\n    sum += data[i];\n  }\n  return sum / dataSize;\n}\n\n/**\n * @brief Compute median value for the array.\n *\n * @param data Array to compute median.\n * @param dataSize Length of the array.\n * @return Median value.\n */\nint median(int *data, int dataSize) {\n  int temp;\n  int i, j;\n  // the following two loops sort the array x in ascending order\n  for (i = 0; i < dataSize - 1; i++) {\n    for (j = i + 1; j < dataSize; j++) {\n      if (data[j] < data[i]) {\n        // swap elements\n        temp = data[i];\n        data[i] = data[j];\n        data[j] = temp;\n      }\n    }\n  }\n  return data[dataSize / 2];\n}\n\n/**\n * @brief Copy ManagedString to char array with max size.\n * \n * @param dst char array as destination\n * @param mstr string as source\n * @param maxLength max size to copy\n */\nvoid copyManagedString(char *dst, ManagedString mstr, size_t maxLength) {\n  memcpy(dst, mstr.toCharArray(), ((size_t)mstr.length() < maxLength ? mstr.length() : maxLength));\n}\n\n/**\n * Position of data format in a value holder.\n */\n#define MBIT_MORE_DATA_FORMAT_INDEX 19\n\n#include \"MbitMoreDevice.h\"\n\n/**\n * Constructor.\n * Create a representation of the device for Microbit More service.\n * @param _uBit The instance of a MicroBit runtime.\n */\nMbitMoreDevice::MbitMoreDevice(MicroBit &_uBit) : uBit(_uBit) {\n  // Reset compass\n#if MICROBIT_CODAL\n  // On microbit-v2, re-calibration destract compass heading.\n#else // NOT MICROBIT_CODAL\n  if (uBit.buttonA.isPressed()) {\n    uBit.compass.clearCalibration();\n  }\n#endif // NOT MICROBIT_CODAL\n\n  // Compass must be calibrated before starting bluetooth service.\n  if (!uBit.compass.isCalibrated()) {\n    uBit.compass.calibrate();\n  }\n\n  displayVersion();\n\n  uBit.messageBus.listen(\n      MICROBIT_ID_BUTTON_A, MICROBIT_EVT_ANY,\n      this,\n      &MbitMoreDevice::onButtonChanged,\n      MESSAGE_BUS_LISTENER_QUEUE_IF_BUSY);\n  uBit.messageBus.listen(\n      MICROBIT_ID_BUTTON_B,\n      MICROBIT_EVT_ANY,\n      this,\n      &MbitMoreDevice::onButtonChanged,\n      MESSAGE_BUS_LISTENER_QUEUE_IF_BUSY);\n\n#if MICROBIT_CODAL\n  uBit.messageBus.listen(\n      MICROBIT_ID_LOGO,\n      MICROBIT_EVT_ANY,\n      this,\n      &MbitMoreDevice::onButtonChanged,\n      MESSAGE_BUS_LISTENER_QUEUE_IF_BUSY);\n#endif // MICROBIT_CODAL\n\n  uBit.messageBus.listen(\n      MICROBIT_ID_GESTURE,\n      MICROBIT_EVT_ANY,\n      this,\n      &MbitMoreDevice::onGestureChanged,\n      MESSAGE_BUS_LISTENER_QUEUE_IF_BUSY);\n\n  uBit.messageBus.listen(\n      MICROBIT_ID_BLE,\n      MICROBIT_BLE_EVT_CONNECTED,\n      this,\n      &MbitMoreDevice::onBLEConnected,\n      MESSAGE_BUS_LISTENER_QUEUE_IF_BUSY);\n  uBit.messageBus.listen(\n      MICROBIT_ID_BLE,\n      MICROBIT_BLE_EVT_DISCONNECTED,\n      this,\n      &MbitMoreDevice::onBLEDisconnected,\n      MESSAGE_BUS_LISTENER_QUEUE_IF_BUSY);\n#if MBIT_MORE_USE_SERIAL\n  serialService = new MbitMoreSerial(*this);\n#endif // MBIT_MORE_USE_SERIAL\n}\n\nMbitMoreDevice::~MbitMoreDevice() {\n  uBit.messageBus.ignore(MICROBIT_ID_BUTTON_A, MICROBIT_EVT_ANY, this,\n                         &MbitMoreDevice::onButtonChanged);\n  uBit.messageBus.ignore(MICROBIT_ID_BUTTON_B, MICROBIT_EVT_ANY, this,\n                         &MbitMoreDevice::onButtonChanged);\n  uBit.messageBus.ignore(MICROBIT_ID_GESTURE, MICROBIT_EVT_ANY, this,\n                         &MbitMoreDevice::onGestureChanged);\n  uBit.messageBus.ignore(MICROBIT_ID_ANY, MICROBIT_EVT_ANY, this,\n                         &MbitMoreDevice::onPinEvent);\n  delete basicService;\n}\n\n/**\n * @brief Set pin configuration for initial.\n *\n */\nvoid MbitMoreDevice::initializeConfig() {\n  // P0,P1,P2 are pull-up as standard extension.\n  for (size_t i = 0; i < (sizeof(initialPullUp) / sizeof(initialPullUp[0])); i++) {\n    setPullMode(initialPullUp[i], MbitMorePullMode::Up);\n    uBit.io.pin[initialPullUp[i]].getDigitalValue(); // set the pin to input-mode\n  }\n}\n\n/**\n * @brief Update version data on the characteristic.\n * \n */\nvoid MbitMoreDevice::updateVersionData() {\n  uint8_t *data = moreService->commandChBuffer;\n#if MICROBIT_CODAL\n  data[0] = MbitMoreHardwareVersion::MICROBIT_V2;\n#else // NOT MICROBIT_CODAL\n  data[0] = MbitMoreHardwareVersion::MICROBIT_V1;\n#endif // NOT MICROBIT_CODAL\n  data[1] = MbitMoreProtocol::MBIT_MORE_V2;\n}\n\n/**\n * @brief Invoked when BLE connected.\n * \n * @param _e event which has connection data\n */\nvoid MbitMoreDevice::onBLEConnected(MicroBitEvent _e) {\n#if MICROBIT_CODAL\n  fiber_sleep(100); // to change pull-mode in micro:bit v2\n#endif // MICROBIT_CODAL\n  initializeConfig();\n  uBit.display.stopAnimation(); // To stop display friendly name.\n  uBit.display.print(\"M\");\n}\n\n/**\n * @brief Invoked when BLE disconnected.\n * \n * @param _e event which has disconnection data\n */\nvoid MbitMoreDevice::onBLEDisconnected(MicroBitEvent _e) {\n  uBit.reset(); // reset to off microphone and its LED.\n}\n\nvoid MbitMoreDevice::onSerialConnected() {\n  uBit.ble->stopAdvertising();\n  initializeConfig();\n  uBit.display.stopAnimation(); // To stop display friendly name.\n  uBit.display.print(\"M\");\n  serialConnected = true;\n}\n\n/**\n * @brief Call when a command was received.\n *\n * @param data\n * @param length\n */\nvoid MbitMoreDevice::onCommandReceived(uint8_t *data, size_t length) {\n  const int command = (data[0] >> 5);\n  if (command == MbitMoreCommand::CMD_DISPLAY) {\n    const int displayCommand = data[0] & 0b11111;\n    if (displayCommand == MbitMoreDisplayCommand::TEXT) {\n      char text[length - 1] = {0};\n      memcpy(text, &(data[2]), length - 2);\n      displayText(text, (data[1] * 10));\n    } else if (displayCommand == MbitMoreDisplayCommand::PIXELS_0) {\n      setPixelsShadowLine(0, &data[1]);\n      setPixelsShadowLine(1, &data[6]);\n      setPixelsShadowLine(2, &data[11]);\n    } else if (displayCommand == MbitMoreDisplayCommand::PIXELS_1) {\n      setPixelsShadowLine(3, &data[1]);\n      setPixelsShadowLine(4, &data[6]);\n      displayShadowPixels();\n    }\n  } else if (command == MbitMoreCommand::CMD_PIN) {\n    const int pinCommand = data[0] & 0b11111;\n    int pinIndex = (int)data[1];\n    if (pinCommand == MbitMorePinCommand::SET_PULL) {\n      uBit.io.pin[pinIndex].getDigitalValue(); // set the pin to input mode\n      setPullMode(pinIndex, (MbitMorePullMode)data[2]);\n    } else if (pinCommand == MbitMorePinCommand::SET_OUTPUT) {\n#if MICROBIT_CODAL\n      // workaround to set d-out from touch-mode in microbit-codal-v2\n      if (touchMode[pinIndex]) {\n        uBit.io.pin[pinIndex].setAnalogValue(0);\n      }\n#endif // MICROBIT_CODAL\n      setDigitalValue(pinIndex, data[2]);\n    } else if (pinCommand == MbitMorePinCommand::SET_PWM) {\n      // value is read as uint16_t little-endian.\n      uint16_t value;\n      memcpy(&value, &(data[2]), 2);\n      setAnalogValue(pinIndex, value);\n    } else if (pinCommand == MbitMorePinCommand::SET_SERVO) {\n      // angle is read as uint16_t little-endian.\n      uint16_t angle;\n      memcpy(&angle, &(data[2]), 2);\n      // range is read as uint16_t little-endian.\n      uint16_t range;\n      memcpy(&range, &(data[4]), 2);\n      // center is read as uint16_t little-endian.\n      uint16_t center;\n      memcpy(&center, &(data[6]), 2);\n      if (range == 0) {\n        uBit.io.pin[pinIndex].setServoValue(angle);\n      } else if (center == 0) {\n        uBit.io.pin[pinIndex].setServoValue(angle, range);\n      } else {\n        uBit.io.pin[pinIndex].setServoValue(angle, range, center);\n      }\n    } else if (pinCommand == MbitMorePinCommand::SET_EVENT) {\n      listenPinEventOn(pinIndex, (int)data[2]);\n    }\n    touchMode[pinIndex] = false;\n  } else if (command == MbitMoreCommand::CMD_AUDIO) {\n    int audioCommand = data[0] & 0b11111;\n    if (audioCommand == MbitMoreAudioCommand::PLAY_TONE) {\n      uint32_t period;\n      memcpy(&period, &(data[1]), 4);\n      playTone(period, data[5]);\n    } else if (audioCommand == MbitMoreAudioCommand::STOP_TONE) {\n      stopTone();\n    }\n#if MICROBIT_CODAL\n  } else if (command == MbitMoreCommand::CMD_DATA) {\n    MbitMoreDataContentType dataType = (MbitMoreDataContentType)(data[0] & 0b11111);\n    int index = findWaitingDataLabelIndex((char *)(&data[1]), dataType);\n    if (index != MBIT_MORE_WAITING_DATA_LABEL_NOT_FOUND) {\n      int contentStart = 1 + MBIT_MORE_DATA_LABEL_SIZE;\n      memset(receivedData[index].content, 0, MBIT_MORE_DATA_CONTENT_SIZE);\n      memcpy(receivedData[index].content, &data[contentStart], length - contentStart);\n      MicroBitEvent evt(MBIT_MORE_DATA_RECEIVED, index + 1);\n    }\n#endif // MICROBIT_CODAL\n  } else if (command == MbitMoreCommand::CMD_CONFIG) {\n    const int config = data[0] & 0b11111;\n    if (config == MbitMoreConfig::MIC) {\n#if MICROBIT_CODAL\n      micInUse = ((data[1] == 1) ? true : false);\n#endif // MICROBIT_CODAL\n    } else if (config == MbitMoreConfig::TOUCH) {\n      int pinIndex = data[1];\n      if (pinIndex > 2)\n        return;\n      int componentID = pinIndex + 100;\n      if (data[2] == 1) {\n        uBit.messageBus.listen(\n            componentID,\n            MICROBIT_EVT_ANY,\n            this,\n            &MbitMoreDevice::onButtonChanged,\n            MESSAGE_BUS_LISTENER_QUEUE_IF_BUSY);\n#if MICROBIT_CODAL\n        uBit.io.pin[pinIndex].isTouched();\n        // uBit.io.pin[pinIndex].isTouched(TouchMode::Capacitative); // does not work?\n#else // NOT MICROBIT_CODAL\n        uBit.io.pin[pinIndex].isTouched();\n#endif // NOT MICROBIT_CODAL\n        touchMode[pinIndex] = true;\n      } else {\n        uBit.messageBus.ignore(\n            componentID,\n            MICROBIT_EVT_ANY,\n            this,\n            &MbitMoreDevice::onButtonChanged);\n      }\n    }\n  }\n}\n\n/**\n * @brief Set the pattern on the line of the shadow pixels.\n *\n * @param line Index of the lines to set.\n * @param pattern Array of brightness(0..255) according columns.\n */\nvoid MbitMoreDevice::setPixelsShadowLine(int line, uint8_t *pattern) {\n  for (size_t col = 0; col < 5; col++) {\n    shadowPixcels[line][col] = pattern[col];\n  }\n}\n\n/**\n * @brief Display the shadow pixels on the LED.\n *\n */\nvoid MbitMoreDevice::displayShadowPixels() {\n  uBit.display.stopAnimation();\n  for (size_t y = 0; y < 5; y++) {\n    for (size_t x = 0; x < 5; x++) {\n      uBit.display.image.setPixelValue(x, y, shadowPixcels[y][x]);\n    }\n  }\n}\n\n/**\n * @brief Display text on LED.\n *\n * @param text Contents to display with null termination.\n * @param delay The time to delay between characters, in milliseconds.\n */\nvoid MbitMoreDevice::displayText(char *text, int delay) {\n  ManagedString mstr(text);\n  uBit.display.stopAnimation();\n  // Interval=120 is corresponding with the standard extension.\n  uBit.display.scrollAsync(mstr, delay);\n}\n\n/**\n * @brief Update GPIO and sensors state.\n *\n * @param data Buffer for BLE characteristics.\n */\nvoid MbitMoreDevice::updateState(uint8_t *data) {\n  uint32_t digitalLevels = 0;\n  for (size_t i = 0; i < sizeof(gpioPin) / sizeof(gpioPin[0]); i++) {\n    if (uBit.io.pin[gpioPin[i]].isDigital()) {\n      if (uBit.io.pin[gpioPin[i]].isInput()) {\n        digitalLevels =\n            digitalLevels |\n            (uBit.io.pin[gpioPin[i]].getDigitalValue() << gpioPin[i]);\n      }\n    }\n  }\n  if (touchMode[0]) {\n    digitalLevels = digitalLevels | (uBit.io.pin[0].isTouched() << MbitMoreButtonStateIndex::P0);\n  }\n  if (touchMode[1]) {\n    digitalLevels = digitalLevels | (uBit.io.pin[1].isTouched() << MbitMoreButtonStateIndex::P1);\n  }\n  if (touchMode[2]) {\n    digitalLevels = digitalLevels | (uBit.io.pin[2].isTouched() << MbitMoreButtonStateIndex::P2);\n  }\n  digitalLevels = digitalLevels | (uBit.buttonA.isPressed() << MbitMoreButtonStateIndex::A);\n  digitalLevels = digitalLevels | (uBit.buttonB.isPressed() << MbitMoreButtonStateIndex::B);\n#if MICROBIT_CODAL\n  digitalLevels = digitalLevels | (uBit.logo.isPressed() << MbitMoreButtonStateIndex::LOGO);\n#endif // MICROBIT_CODAL\n  memcpy(data, (uint8_t *)&digitalLevels, 4);\n  data[4] = sampleLightLevel();\n  data[5] = (uint8_t)(uBit.thermometer.getTemperature() + 128);\n#if MICROBIT_CODAL\n  if (micInUse) {\n    data[6] = getMicLevel();\n  }\n#endif // MICROBIT_CODAL\n}\n\n/**\n * @brief Update data of motion.\n *\n * @param data Buffer for BLE characteristics.\n */\nvoid MbitMoreDevice::updateMotion(uint8_t *data) {\n  // Accelerometer\n  int16_t rot;\n  // Pitch (radians / 1000) is sent as int16_t little-endian [0..1].\n  rot = (int16_t)(uBit.accelerometer.getPitchRadians() * 1000);\n  memcpy(&(data[0]), &rot, 2);\n  // Roll (radians / 1000) is sent as int16_t little-endian [2..3].\n  rot = (int16_t)(uBit.accelerometer.getRollRadians() * 1000);\n  memcpy(&(data[2]), &rot, 2);\n\n  int16_t acc;\n  // Acceleration X [milli-g] is sent as int16_t little-endian [4..5].\n  acc = (int16_t)-uBit.accelerometer.getX(); // Face side is positive in Z-axis.\n  memcpy(&(data[4]), &acc, 2);\n  // Acceleration Y [milli-g] is sent as int16_t little-endian [6..7].\n  acc = (int16_t)uBit.accelerometer.getY();\n  memcpy(&(data[6]), &acc, 2);\n  // Acceleration Z [milli-g] is sent as int16_t little-endian [8..9].\n  acc = (int16_t)-uBit.accelerometer.getZ(); // Face side is positive in Z-axis.\n  memcpy(&(data[8]), &acc, 2);\n\n  // Magnetometer\n  // Compass Heading is sent as uint16_t little-endian [10..11]\n  uint16_t heading = (uint16_t)normalizeCompassHeading(uBit.compass.heading());\n  memcpy(&(data[10]), &heading, 2);\n\n  int16_t force;\n  // Magnetic force X (micro-teslas) is sent as int16_t little-endian[12..13].\n  force = (int16_t)(uBit.compass.getX() / 1000);\n  memcpy(&(data[12]), &force, 2);\n  // Magnetic force Y (micro-teslas) is sent as int16_t little-endian[14..15].\n  force = (int16_t)(uBit.compass.getY() / 1000);\n  memcpy(&(data[14]), &force, 2);\n  // Magnetic force Z (micro-teslas) is sent as int16_t little-endian[16..17].\n  force = (int16_t)(uBit.compass.getZ() / 1000);\n  memcpy(&(data[16]), &force, 2);\n}\n\n/**\n * @brief Get data of analog input of the pin.\n *\n * @param data Buffer for BLE characteristics.\n * @param pinIndex Index of the pin [0, 1, 2].\n */\nvoid MbitMoreDevice::updateAnalogIn(uint8_t *data, size_t pinIndex) {\n  if (uBit.io.pin[pinIndex].isInput()) {\n#if MICROBIT_CODAL\n    uBit.io.pin[pinIndex].setPull(PullMode::None);\n#else // NOT MICROBIT_CODAL\n    uBit.io.pin[pinIndex].setPull(PinMode::PullNone);\n#endif // NOT MICROBIT_CODAL\n\n    // filter\n    for (size_t i = 0; i < ANALOG_IN_SAMPLES_SIZE; i++) {\n      analogInSamples[pinIndex][i] = uBit.io.pin[pinIndex].getAnalogValue();\n    }\n    uint16_t value = median(analogInSamples[pinIndex], ANALOG_IN_SAMPLES_SIZE);\n\n    // analog value (0 to 1023) is sent as uint16_t little-endian.\n    memcpy(&(data[0]), &value, 2);\n    setPullMode(pinIndex, pullMode[pinIndex]);\n  }\n}\n\n/**\n * @brief Sample current light level and return filtered value.\n *\n * @return int Filtered light level.\n */\nint MbitMoreDevice::sampleLightLevel() {\n  lightLevelSamplesLast++;\n  if (lightLevelSamplesLast == LIGHT_LEVEL_SAMPLES_SIZE) {\n    lightLevelSamplesLast = 0;\n  }\n  lightLevelSamples[lightLevelSamplesLast] = uBit.display.readLightLevel();\n  return average(lightLevelSamples, LIGHT_LEVEL_SAMPLES_SIZE);\n}\n\n/**\n * @brief Set PMW signal to the pin for play tone.\n * \n * @param period  PWM period (1000000 / frequency)[us]\n * @param volume laudness of the sound [0..255]\n */\nvoid MbitMoreDevice::playTone(int period, int volume) {\n#if MICROBIT_CODAL\n  MicroBitPin speakerPin = uBit.io.speaker;\n#else // NOT MICROBIT_CODAL\n  MicroBitPin speakerPin = uBit.io.pin[0];\n#endif // NOT MICROBIT_CODAL\n  if (period <= 0 || volume == 0) {\n    speakerPin.setAnalogValue(0);\n  } else {\n    int v = 1 << (volume >> 5); // [2..14]\n    speakerPin.setAnalogValue(v);\n    speakerPin.setAnalogPeriodUs(period);\n  }\n}\n\n/**\n * @brief Stop playing tone.\n * \n */\nvoid MbitMoreDevice::stopTone() {\n#if MICROBIT_CODAL\n  MicroBitPin speakerPin = uBit.io.speaker;\n#else // NOT MICROBIT_CODAL\n  MicroBitPin speakerPin = uBit.io.pin[0];\n#endif // NOT MICROBIT_CODAL\n  speakerPin.setAnalogValue(0);\n}\n\n#if MICROBIT_CODAL\n/**\n * @brief Return index for the label\n * \n * @param dataLabel label to find\n * @param dataType type of the data\n * @return int index of the label\n */\nint MbitMoreDevice::findWaitingDataLabelIndex(const char *dataLabel, MbitMoreDataContentType dataType) {\n  for (int i = 0; i < MBIT_MORE_WAITING_DATA_LABELS_LENGTH; i++) {\n    if (receivedData[i].label[0] == 0)\n      continue;\n    if (receivedData[i].type == dataType) {\n      if (0 == strncmp(receivedData[i].label,\n                       dataLabel,\n                       MBIT_MORE_DATA_LABEL_SIZE)) {\n        return i;\n      }\n    }\n  }\n  return MBIT_MORE_WAITING_DATA_LABEL_NOT_FOUND;\n}\n\n/**\n * @brief Register data label and retrun ID for the label.\n *\n * @param dataLabel label to register\n * @param dataType type of the data\n * @return int ID for the label\n */\nint MbitMoreDevice::registerWaitingDataLabel(ManagedString dataLabel, MbitMoreDataContentType dataType) {\n  int index = findWaitingDataLabelIndex(dataLabel.toCharArray(), dataType);\n  if (index == MBIT_MORE_WAITING_DATA_LABEL_NOT_FOUND) {\n    // find blank index and resister it\n    for (int i = 0; i < MBIT_MORE_WAITING_DATA_LABELS_LENGTH; i++) {\n      if (receivedData[i].label[0] == 0) {\n        index = i;\n        receivedData[index].type = dataType;\n        strncpy(\n            receivedData[index].label,\n            dataLabel.toCharArray(),\n            MBIT_MORE_DATA_LABEL_SIZE);\n        return index + 1; // It is used for event value and must not be 0 (0 to accept any events).\n      }\n    }\n  }\n  return 0;\n}\n\n/**\n * @brief Get type of content for the labeled data\n *\n * @param labelID ID of the label in received data\n * @return content type\n */\nMbitMoreDataContentType MbitMoreDevice::dataType(int labelID) {\n  return receivedData[labelID - 1].type;\n}\n\n/**\n * @brief Return content of the data as number\n *\n * @param labelID ID of the label in received data\n * @return content of the data\n */\nfloat MbitMoreDevice::dataContentAsNumber(int labelID) {\n  float content;\n  memcpy(&content, receivedData[labelID - 1].content, 4);\n  return content;\n}\n\n/**\n * @brief Return content of the data as text\n *\n * @param labelID ID of the label in received data\n * @return content of the data\n */\nManagedString MbitMoreDevice::dataContentAsText(int labelID) {\n  return ManagedString((char *)(receivedData[labelID - 1].content));\n}\n\n/**\n * @brief Send number with label.\n * \n * @param dataLabel \n * @param dataContent \n */\nvoid MbitMoreDevice::sendNumberWithLabel(ManagedString dataLabel, float dataContent) {\n  uint8_t *data = moreService->dataChBuffer;\n  memset(data, 0, MM_CH_BUFFER_SIZE_NOTIFY);\n  copyManagedString((char *)(&data[0]), dataLabel, MBIT_MORE_DATA_LABEL_SIZE);\n  memcpy(&data[MBIT_MORE_DATA_LABEL_SIZE], &dataContent, 4);\n  data[MBIT_MORE_DATA_FORMAT_INDEX] = MbitMoreDataFormat::DATA_NUMBER;\n#if MBIT_MORE_USE_SERIAL\n  if (serialConnected) {\n    serialService->notifyOnSerial(0x0130, data, MM_CH_BUFFER_SIZE_NOTIFY);\n    return;\n  }\n#endif // MBIT_MORE_USE_SERIAL\n  moreService->notifyData();\n}\n\n/**\n * @brief Send text with label.\n * \n * @param dataLabel \n * @param dataContent \n */\nvoid MbitMoreDevice::sendTextWithLabel(ManagedString dataLabel, ManagedString dataContent) {\n  uint8_t *data = moreService->dataChBuffer;\n  memset(data, 0, MM_CH_BUFFER_SIZE_NOTIFY);\n  copyManagedString(\n      (char *)(&data[0]),\n      dataLabel,\n      MBIT_MORE_DATA_LABEL_SIZE);\n  copyManagedString(\n      (char *)(&data[MBIT_MORE_DATA_LABEL_SIZE]),\n      dataContent,\n      MBIT_MORE_DATA_CONTENT_SIZE);\n  data[MBIT_MORE_DATA_FORMAT_INDEX] = MbitMoreDataFormat::DATA_TEXT;\n#if MBIT_MORE_USE_SERIAL\n  if (serialConnected) {\n    serialService->notifyOnSerial(0x0130, data, MM_CH_BUFFER_SIZE_NOTIFY);\n    return;\n  }\n#endif // MBIT_MORE_USE_SERIAL\n  moreService->notifyData();\n}\n\n#endif // MICROBIT_CODAL\n\n/**\n * @brief Listen pin events on the pin.\n * Make it listen events of the event type on the pin.\n * Remove listener if the event type is MICROBIT_PIN_EVENT_NONE.\n * \n * @param pinIndex index in edge pins\n * @param eventType type of events\n */\nvoid MbitMoreDevice::listenPinEventOn(int pinIndex, int eventType) {\n  if (!isGpio(pinIndex)) {\n    return;\n  }\n  int componentID = pinIndex + 100; // conventional scheme to convert from pin\n                                    // index to componentID in v1 and v2.\n  uBit.messageBus.ignore(\n      componentID,\n      MICROBIT_PIN_EVT_RISE,\n      this,\n      &MbitMoreDevice::onPinEvent);\n  uBit.messageBus.ignore(\n      componentID,\n      MICROBIT_PIN_EVT_FALL,\n      this,\n      &MbitMoreDevice::onPinEvent);\n  uBit.messageBus.ignore(\n      componentID,\n      MICROBIT_PIN_EVT_PULSE_HI,\n      this,\n      &MbitMoreDevice::onPinEvent);\n  uBit.messageBus.ignore(\n      componentID,\n      MICROBIT_PIN_EVT_PULSE_LO,\n      this,\n      &MbitMoreDevice::onPinEvent);\n\n  if (eventType == MbitMorePinEventType::ON_EDGE) {\n    uBit.messageBus.listen(\n        componentID,\n        MICROBIT_PIN_EVT_RISE,\n        this,\n        &MbitMoreDevice::onPinEvent,\n        MESSAGE_BUS_LISTENER_QUEUE_IF_BUSY);\n    uBit.messageBus.listen(\n        componentID,\n        MICROBIT_PIN_EVT_FALL,\n        this,\n        &MbitMoreDevice::onPinEvent,\n        MESSAGE_BUS_LISTENER_QUEUE_IF_BUSY);\n    uBit.io.pin[pinIndex].eventOn(MICROBIT_PIN_EVENT_ON_EDGE);\n  } else if (eventType == MbitMorePinEventType::ON_PULSE) {\n    uBit.messageBus.listen(\n        componentID,\n        MICROBIT_PIN_EVT_PULSE_HI,\n        this,\n        &MbitMoreDevice::onPinEvent,\n        MESSAGE_BUS_LISTENER_QUEUE_IF_BUSY);\n    uBit.messageBus.listen(\n        componentID,\n        MICROBIT_PIN_EVT_PULSE_LO,\n        this,\n        &MbitMoreDevice::onPinEvent,\n        MESSAGE_BUS_LISTENER_QUEUE_IF_BUSY);\n#if MICROBIT_CODAL\n    // ?? Freeze BLE when onEvent(PULSE) first time. ??\n    uBit.io.pin[pinIndex].eventOn(MICROBIT_PIN_EVENT_NONE); // workaround to prevent to freeze BLE\n    uBit.io.pin[pinIndex].eventOn(MICROBIT_PIN_EVENT_ON_PULSE);\n    // ?? Pull-mode is released and will not be reset in this thread. ??\n    setPullMode(pinIndex, pullMode[pinIndex]); // does not work?\n#else // NOT MICROBIT_CODAL\n    uBit.io.pin[pinIndex].eventOn(MICROBIT_PIN_EVENT_ON_PULSE);\n#endif // NOT MICROBIT_CODAL\n  } else if (eventType == MbitMorePinEventType::NONE) {\n    uBit.io.pin[pinIndex].eventOn(MICROBIT_PIN_EVENT_NONE);\n#if MICROBIT_CODAL\n    // ?? Pull-mode is released and will not be reset in this thread. ??\n    setPullMode(pinIndex, pullMode[pinIndex]); // does not work?\n#endif // MICROBIT_CODAL\n  }\n}\n\n/**\n * Callback. Invoked when a pin event sent.\n */\nvoid MbitMoreDevice::onPinEvent(MicroBitEvent evt) {\n  uint8_t *data = moreService->pinEventChBuffer;\n\n  // pinIndex is sent as uint8_t.\n  data[0] = evt.source - 100; // conventional scheme to convert from componentID\n                              // to pin index in v1 and v2.\n\n  // event ID is sent as uint8_t.\n  data[1] = (uint8_t)evt.value;\n\n  // event timestamp is sent as uint32_t little-endian\n  // downcast from uint64_t value.\n  uint32_t timestamp = (uint32_t)evt.timestamp;\n  memcpy(&(data[2]), &timestamp, 4);\n  data[MBIT_MORE_DATA_FORMAT_INDEX] = MbitMoreDataFormat::PIN_EVENT;\n#if MBIT_MORE_USE_SERIAL\n  if (serialConnected) {\n    serialService->notifyOnSerial(0x0110, data, MM_CH_BUFFER_SIZE_NOTIFY);\n    return;\n  }\n#endif // MBIT_MORE_USE_SERIAL\n  moreService->notifyPinEvent();\n}\n\n/**\n * @brief Invoked when button state changed.\n * \n * @param evt event which has button states\n */\nvoid MbitMoreDevice::onButtonChanged(MicroBitEvent evt) {\n  uint8_t *data = moreService->actionEventChBuffer;\n  data[0] = MbitMoreActionEvent::BUTTON;\n  // source is a component ID that generated the event as uint16_t little-endian.\n  // MICROBIT_ID_BUTTON_A, MICROBIT_ID_IO_P0, MICROBIT_ID_LOGO, etc.\n  memcpy(&(data[1]), &evt.source, 2);\n  // Event ID send as uint16_t little-endian.\n  // MICROBIT_BUTTON_EVT_DOWN, MICROBIT_BUTTON_EVT_CLICK, etc.\n  data[3] = (uint8_t)evt.value;\n  // Timestamp of the event send as uint32_t little-endian.\n  // downcast from uint64_t value.\n  uint32_t timestamp = (uint32_t)evt.timestamp;\n  memcpy(&(data[4]), &timestamp, 4);\n  data[MBIT_MORE_DATA_FORMAT_INDEX] = MbitMoreDataFormat::ACTION_EVENT;\n#if MBIT_MORE_USE_SERIAL\n  if (serialConnected) {\n    serialService->notifyOnSerial(0x0111, data, MM_CH_BUFFER_SIZE_NOTIFY);\n    return;\n  }\n#endif // MBIT_MORE_USE_SERIAL\n  moreService->notifyActionEvent();\n}\n\n/**\n * @brief Invoked when gesture state changed.\n * \n * @param evt event which has gesture states.\n */\nvoid MbitMoreDevice::onGestureChanged(MicroBitEvent evt) {\n  uint8_t *data = moreService->actionEventChBuffer;\n  data[0] = MbitMoreActionEvent::GESTURE;\n  // Event ID send as uint8_t.\n  // MICROBIT_ACCELEROMETER_EVT_TILT_UP, MICROBIT_ACCELEROMETER_EVT_FACE_UP, etc.\n  data[1] = (uint8_t)evt.value;\n  // Timestamp of the event send as uint32_t little-endian.\n  // downcast from uint64_t value.\n  uint32_t timestamp = (uint32_t)evt.timestamp;\n  memcpy(&(data[2]), &timestamp, 4);\n  data[MBIT_MORE_DATA_FORMAT_INDEX] = MbitMoreDataFormat::ACTION_EVENT;\n#if MICROBIT_CODAL\n  if (serialConnected) {\n    serialService->notifyOnSerial(0x0111, data, MM_CH_BUFFER_SIZE_NOTIFY);\n    return;\n  }\n#endif // MICROBIT_CODAL\n  moreService->notifyActionEvent();\n}\n\n/**\n * @brief Normalize angle when upside down.\n * \n * @param heading value of the compass heading\n * @return normalizes angle relative to north [degree]\n */\nint MbitMoreDevice::normalizeCompassHeading(int heading) {\n  if (uBit.accelerometer.getZ() > 0) {\n    if (heading <= 180) {\n      heading = 180 - heading;\n    } else {\n      heading = 360 - (heading - 180);\n    }\n  }\n  return heading;\n}\n\n/**\n * @brief Set pull-mode.\n * \n * @param pinIndex index to set\n * @param pull pull-mode to set\n */\nvoid MbitMoreDevice::setPullMode(int pinIndex, MbitMorePullMode pull) {\n  pullMode[pinIndex] = pull;\n#if MICROBIT_CODAL\n  switch (pull) {\n  case MbitMorePullMode::None:\n    uBit.io.pin[pinIndex].setPull(PullMode::None);\n    break;\n  case MbitMorePullMode::Up:\n    uBit.io.pin[pinIndex].setPull(PullMode::Up);\n    break;\n  case MbitMorePullMode::Down:\n    uBit.io.pin[pinIndex].setPull(PullMode::Down);\n    break;\n\n  default:\n    break;\n  }\n#else // NOT MICROBIT_CODAL\n  switch (pull) {\n  case MbitMorePullMode::None:\n    uBit.io.pin[pinIndex].setPull(PinMode::PullNone);\n    break;\n  case MbitMorePullMode::Up:\n    uBit.io.pin[pinIndex].setPull(PinMode::PullUp);\n    break;\n  case MbitMorePullMode::Down:\n    uBit.io.pin[pinIndex].setPull(PinMode::PullDown);\n    break;\n\n  default:\n    break;\n  }\n#endif // NOT MICROBIT_CODAL\n}\n\n/**\n * @brief Set the value on the pin as digital output.\n * \n * @param pinIndex index in edge pins\n * @param value digital value [0 | 1]\n */\nvoid MbitMoreDevice::setDigitalValue(int pinIndex, int value) {\n  uBit.io.pin[pinIndex].setDigitalValue(value);\n}\n\n/**\n * @brief Set the value on the pin as analog output (PWM).\n * \n * @param pinIndex index in edge pins\n * @param value analog value (0..1024)\n */\nvoid MbitMoreDevice::setAnalogValue(int pinIndex, int value) {\n#if MICROBIT_CODAL\n  // stable level is 0 .. 1022 in micro:bit v2,\n  int validValue = value > 1022 ? 1022 : value;\n#else // NOT MICROBIT_CODAL\n  // stable level is 0 .. 1021 in micro:bit v1.5,\n  int validValue = value > 1021 ? 1021 : value;\n#endif // NOT MICROBIT_CODAL\n  uBit.io.pin[pinIndex].setAnalogValue(validValue);\n}\n\n/**\n * @brief Set the value on the pin as servo driver.\n * \n * @param pinIndex index in edge pins\n * @param angle the level to set on the output pin, in the range 0 - 180.\n * @param range which gives the span of possible values the i.e. the lower and upper bounds (center +/- range/2). Defaults to DEVICE_PIN_DEFAULT_SERVO_RANGE.\n * @param center the center point from which to calculate the lower and upper bounds. Defaults to DEVICE_PIN_DEFAULT_SERVO_CENTER\n */\nvoid MbitMoreDevice::setServoValue(int pinIndex, int angle, int range,\n                                   int center) {\n  uBit.io.pin[pinIndex].setServoValue(angle, range, center);\n}\n\n/**\n * @brief Display friendly name of the micro:bit.\n * \n */\nvoid MbitMoreDevice::displayFriendlyName() {\n  if (serialConnected)\n    return;\n  uBit.display.scrollAsync(ManagedString(microbit_friendly_name()), 120);\n}\n\n/**\n * @brief Display software version of Microbit More.\n * \n */\nvoid MbitMoreDevice::displayVersion() {\n  uBit.display.scrollAsync(ManagedString(\" -M 0.2.3- \"), 120);\n}\n\n/**\n * @brief Whether the pin is a GPIO of not.\n * \n * @param pinIndex index in edge pins\n * @return true the pin is a GPIO\n * @return false the pin is not a GPIO\n */\nbool MbitMoreDevice::isGpio(int pinIndex) {\n  for (size_t i = 0; i < (sizeof(gpioPin) / sizeof(gpioPin[0])); i++) {\n    if (pinIndex == gpioPin[i])\n      return true;\n  }\n  return false;\n}","MbitMoreDevice.h":"#ifndef MBIT_MORE_DEVICE_H\n#define MBIT_MORE_DEVICE_H\n\n#include \"pxt.h\"\n\n#include \"MicroBit.h\"\n#include \"MicroBitConfig.h\"\n\n#include \"MbitMoreCommon.h\"\n\n#if MBIT_MORE_USE_SERIAL\n#include \"MbitMoreSerial.h\"\nclass MbitMoreSerial;\n#endif // MBIT_MORE_USE_SERIAL\n\n#if MICROBIT_CODAL\n#include \"MbitMoreService.h\"\nclass MbitMoreService;\n#else // MICROBIT_CODAL\n#include \"MbitMoreServiceDAL.h\"\nclass MbitMoreServiceDAL;\nusing MbitMoreService = MbitMoreServiceDAL;\n#endif // NOT MICROBIT_CODAL\n\n#if MICROBIT_CODAL\n#define LIGHT_LEVEL_SAMPLES_SIZE 11\n#define ANALOG_IN_SAMPLES_SIZE 5\n#else // NOT MICROBIT_CODAL\n#define LIGHT_LEVEL_SAMPLES_SIZE 5\n#define ANALOG_IN_SAMPLES_SIZE 5\n#endif // NOT MICROBIT_CODAL\n\n#if MICROBIT_CODAL\n#define MBIT_MORE_WAITING_DATA_LABELS_LENGTH 16\n#define MBIT_MORE_WAITING_DATA_LABEL_NOT_FOUND 0xff\n#define MBIT_MORE_DATA_LABEL_SIZE 8\n#define MBIT_MORE_DATA_CONTENT_SIZE 11\n#endif // MICROBIT_CODAL\n\n/**\n * @brief Button ID in MicrobitMore\n * This number is used to memory offset in state data.\n */\nenum MbitMoreButtonStateIndex\n{\n  // GPIO array using [0..20]\n  P0 = 24,\n  P1 = 25,\n  P2 = 26,\n  A = 27,\n  B = 28,\n  LOGO = 29,\n};\n\n/**\n * @brief Version of this micro:bit\n * \n */\nenum MbitMoreHardwareVersion\n{\n  MICROBIT_V1 = 1,\n  MICROBIT_V2 = 2,\n};\n\n/**\n * @brief Version of protocol to use\n * \n */\nenum MbitMoreProtocol\n{\n  MBIT_MORE_V2 = 2,\n};\n\n/**\n * Class definition for main logics of Micribit More Service except bluetooth connectivity.\n *\n */\nclass MbitMoreDevice {\nprivate:\n  /**\n   * Constructor.\n   * Create a representation of default extension for Scratch3.\n   * @param _uBit The instance of a MicroBit runtime.\n   */\n  MbitMoreDevice(MicroBit &_uBit);\n\n  /**\n   * @brief Destroy the MbitMoreDevice object\n   *\n   */\n  ~MbitMoreDevice();\n\npublic:\n  // setup the class as singleton\n  MbitMoreDevice(const MbitMoreDevice &) = delete;\n  MbitMoreDevice &operator=(const MbitMoreDevice &) = delete;\n  MbitMoreDevice(MbitMoreDevice &&) = delete;\n  MbitMoreDevice &operator=(MbitMoreDevice &&) = delete;\n\n  /**\n   * @brief Get the Instance object as singleton\n   * \n   * @return MbitMoreDevice& \n   */\n  static MbitMoreDevice &getInstance() {\n    static MbitMoreDevice instance(pxt::uBit);\n    return instance;\n  }\n\n  /**\n   * @brief Microbit runtime\n   * \n   */\n  MicroBit &uBit;\n\n  /**\n   * @brief BLE service for basic micro:bit extension.\n   *\n   */\n  MbitMoreService *basicService;\n\n  /**\n   * @brief BLE service for Microbit More extension.\n   *\n   */\n  MbitMoreService *moreService;\n\n#if MBIT_MORE_USE_SERIAL\n  /**\n   * @brief Microbit More serial port connector.\n   * \n   */\n  MbitMoreSerial *serialService;\n#endif // MBIT_MORE_USE_SERIAL\n\n  // ---------------------\n\n  /**\n   * @brief Whether the serial port communication is started. \n   * \n   */\n  bool serialConnected = false;\n\n  /**\n   * @brief Index of controllabel GPIO pins.\n   * \n   */\n  int gpioPin[9] = {0, 1, 2, 8, 12, 13, 14, 15, 16};\n\n  /**\n   * @brief Pins which is pull-up at connected.\n   * \n   */\n  int initialPullUp[3] = {0, 1, 2};\n\n  bool touchMode[3] = {false};\n\n  /**\n   * @brief Shadow screen to display on the LED.\n   *\n   */\n  uint8_t shadowPixcels[5][5] = {{0}};\n\n  /**\n   * Samples of Light Level.\n   */\n  int lightLevelSamples[LIGHT_LEVEL_SAMPLES_SIZE] = {0};\n\n  /**\n   * @brief Last index of the Light Level Samples.\n   *\n   */\n  size_t lightLevelSamplesLast = 0;\n\n#if MICROBIT_CODAL\n  /**\n   * @brief Structure of received data in MbitMore.\n   * \n   */\n  typedef struct {\n    char label[MBIT_MORE_DATA_LABEL_SIZE];            /** label of the data */\n    MbitMoreDataContentType type;                     /** type of the content */\n    uint8_t content[MBIT_MORE_DATA_CONTENT_SIZE + 1]; /** content of the data */\n  } MbitMoreLabeledData;\n\n  /**\n   * @brief Store of received data from Scratch.\n   * \n   */\n  MbitMoreLabeledData receivedData[MBIT_MORE_WAITING_DATA_LABELS_LENGTH] = {{{0}}};\n#endif // MICROBIT_CODAL\n\n  /**\n   * Samples of Light Level.\n   */\n  int analogInSamples[3][ANALOG_IN_SAMPLES_SIZE] = {{0}};\n\n#if MICROBIT_CODAL\n  /**\n   * @brief On-board microphone is in use or not.\n   * \n   */\n  bool micInUse = false;\n\n  /**\n   * @brief Laudness on the microphone.\n   * \n   */\n  float soundLevel = 0.0;\n#endif // MICROBIT_CODAL\n\n  /**\n   * Protocol of microbit more.\n   */\n  int mbitMoreProtocol;\n\n  /**\n   * Current mode of all pins.\n   */\n  MbitMorePullMode pullMode[sizeof(gpioPin) / sizeof(gpioPin[0])];\n\n  /**\n   * @brief Set pin configuration for initial.\n   *\n   */\n  void initializeConfig();\n\n  /**\n   * @brief Update version data on the charactaristic.\n   * \n   */\n  void updateVersionData();\n\n  /**\n   * @brief Invoked when BLE connected.\n   * \n   * @param _e event which has connection data\n   */\n  void onBLEConnected(MicroBitEvent _e);\n\n  /**\n   * @brief Invoked when BLE disconnected.\n   * \n   * @param _e event which has disconnection data\n   */\n  void onBLEDisconnected(MicroBitEvent _e);\n\n  /**\n   * @brief Invoke when serial port connects.\n   * \n   */\n  void onSerialConnected();\n\n  /**\n   * @brief Call when a command was received.\n   *\n   * @param data\n   * @param length\n   */\n  void onCommandReceived(uint8_t *data, size_t length);\n\n  /**\n   * @brief Set the pattern on the line of the shadow pixels.\n   *\n   * @param line Index of the lines to set.\n   * @param pattern Array of brightness(0..255) according columns.\n   */\n  void setPixelsShadowLine(int line, uint8_t *pattern);\n\n  /**\n   * @brief Display the shadow pixels on the LED.\n   *\n   */\n  void displayShadowPixels();\n\n  /**\n   * @brief Display text on LED.\n   *\n   * @param text Contents to display with null termination.\n   * @param delay The time to delay between characters, in milliseconds.\n   */\n  void displayText(char *text, int delay);\n\n  /**\n   * @brief Update GPIO and sensors state.\n   *\n   * @param data Buffer for BLE characteristics.\n   */\n  void updateState(uint8_t *data);\n\n  /**\n   * @brief Update data of motion.\n   *\n   * @param data Buffer for BLE characteristics.\n   */\n  void updateMotion(uint8_t *data);\n\n  /**\n   * @brief Get data of analog input of the pin.\n   *\n   * @param data Buffer for BLE characteristics.\n   * @param pinIndex Index of the pin [0, 1, 2].\n   */\n  void updateAnalogIn(uint8_t *data, size_t pinIndex);\n\n  /**\n   * @brief Sample current light level and return filtered value.\n   *\n   * @return int Filtered light level.\n   */\n  int sampleLightLevel();\n\n  /**\n   * @brief Set PMW signal to the speaker pin for play tone.\n   * \n   * @param period  PWM period (1000000 / frequency)[us]\n   * @param volume laudness of the sound [0..255]\n   */\n  void playTone(int period, int volume);\n\n  /**\n   * @brief Stop playing tone.\n   * \n   */\n  void stopTone();\n\n#if MICROBIT_CODAL\n  /**\n   * @brief Return index for the label\n   * \n   * @param dataLabel label to find\n   * @param dataType type of the data\n   * @return int index of the label\n   */\n  int findWaitingDataLabelIndex(const char *dataLabel, MbitMoreDataContentType dataType);\n\n  /**\n   * @brief Register data label and retrun ID for the label.\n   *\n   * @param dataLabel label to register\n   * @param dataType type of the data\n   * @return int ID for the label\n   */\n  int registerWaitingDataLabel(ManagedString dataLabel, MbitMoreDataContentType dataType);\n\n  /**\n   * @brief Get type of content for the labeled data\n   *\n   * @param labelID ID of the label in received data\n   * @return content type\n   */\n  MbitMoreDataContentType dataType(int labelID);\n\n  /**\n   * @brief Return content of the data as number\n   *\n   * @param labelID ID of the label in received data\n   * @return content of the data\n   */\n  float dataContentAsNumber(int labelID);\n\n  /**\n   * @brief Return content of the data as text\n   *\n   * @param labelID ID of the label in received data\n   * @return content of the data\n   */\n  ManagedString dataContentAsText(int labelID);\n\n  /**\n   * @brief Send number with label.\n   * \n   * @param dataLabel \n   * @param dataContent \n   */\n  void sendNumberWithLabel(ManagedString dataLabel, float dataContent);\n\n  /**\n   * @brief Send text with label.\n   * \n   * @param dataLabel \n   * @param dataContent \n   */\n  void sendTextWithLabel(ManagedString dataLabel, ManagedString dataContent);\n\n#endif // MICROBIT_CODAL\n\n  /**\n   * Callback. Invoked when a pin event sent.\n   */\n  void onPinEvent(MicroBitEvent evt);\n\n  /**\n   * @brief Display friendly name of the micro:bit.\n   * \n   */\n  void displayFriendlyName();\n\n  /**\n   * @brief Display software version of Microbit More.\n   * \n   */\n  void displayVersion();\n\nprivate:\n  /**\n   * @brief Listen pin events on the pin.\n   * Make it listen events of the event type on the pin.\n   * Remove listener if the event type is MICROBIT_PIN_EVENT_NONE.\n   * \n   * @param pinIndex index in edge pins\n   * @param eventType type of events\n   */\n  void listenPinEventOn(int pinIndex, int eventType);\n\n  /**\n   * @brief Set pull-mode.\n   * \n   * @param pinIndex index to set\n   * @param pull pull-mode to set\n   */\n  void setPullMode(int pinIndex, MbitMorePullMode pull);\n\n  /**\n   * @brief Set the value on the pin as digital output.\n   * \n   * @param pinIndex index in edge pins\n   * @param value digital value [0 | 1]\n   */\n  void setDigitalValue(int pinIndex, int value);\n\n  /**\n   * @brief Set the value on the pin as analog output (PWM).\n   * \n   * @param pinIndex index in edge pins\n   * @param value analog value (0..1024)\n   */\n  void setAnalogValue(int pinIndex, int value);\n\n  /**\n   * @brief Set the value on the pin as servo driver.\n   * \n   * @param pinIndex index in edge pins\n   * @param angle the level to set on the output pin, in the range 0 - 180.\n   * @param range which gives the span of possible values the i.e. the lower and upper bounds (center +/- range/2). Defaults to DEVICE_PIN_DEFAULT_SERVO_RANGE.\n   * @param center the center point from which to calculate the lower and upper bounds. Defaults to DEVICE_PIN_DEFAULT_SERVO_CENTER\n   */\n  void setServoValue(int pinIndex, int angle, int range, int center);\n\n  /**\n   * @brief Invoked when button state changed.\n   * \n   * @param evt event which has button states\n   */\n  void onButtonChanged(MicroBitEvent evt);\n\n  /**\n   * @brief Invoked when gesture state changed.\n   * \n   * @param evt event which has gesture states.\n   */\n  void onGestureChanged(MicroBitEvent evt);\n\n  /**\n   * @brief Normalize angle when upside down.\n   * \n   * @param heading value of the compass heading\n   * @return normalizes angle relative to north [degree]\n   */\n  int normalizeCompassHeading(int heading);\n\n  /**\n   * @brief Whether the pin is a GPIO of not.\n   * \n   * @param pinIndex index in edge pins\n   * @return true the pin is a GPIO\n   * @return false the pin is not a GPIO\n   */\n  bool isGpio(int pinIndex);\n};\n\n#endif // MBIT_MORE_DEVICE_H\n","MbitMoreSerial.cpp":"#include \"MbitMoreCommon.h\"\n#if MBIT_MORE_USE_SERIAL\n\n#include \"MbitMoreSerial.h\"\n\nstatic MbitMoreSerial *serial; // Hold it as a static pointer to be called by create_fiber().\n\n/**\n * @brief Start a process to receive data.\n * \n */\nvoid startMbitMoreSerialReceiving() {\n  serial->startSerialReceiving();\n}\n\n/**\n * @brief Start a process to update sensor data.\n * \n */\nvoid startMbitMoreSerialUpdating() {\n  serial->startSerialUpdating();\n}\n\n/**\n * @brief Read one byte from RX. Current fiber sleeps until when received a data.\n * \n * @return uint8_t Data read from RX\n */\nuint8_t readSync() {\n  fiber_sleep(1); // Need to prevent from freezing\n  return uBit.serial.read(SYNC_SLEEP);\n}\n\n/**\n * @brief Calculate checksum of the data. Sum of the buffer and return the remainder which deviced by 0xFF. \n * \n * @param buff Buffer to be calculate\n * @param len Length of buffer\n * @return uint8_t Number of checksum\n */\nuint8_t chksum8(const uint8_t *buff, size_t len) {\n  unsigned int sum;\n  for (sum = 0; len != 0; len--) {\n    sum += *(buff++);\n  }\n  return (uint8_t)(sum % 0xFF);\n}\n\nMbitMoreSerial::MbitMoreSerial(MbitMoreDevice &_mbitMore) : mbitMore(_mbitMore) {\n  serial = this;\n  // Baud rate\n  // int rate = 57600;\n  int rate = 115200; // Default for micro:bit\n#if MICROBIT_CODAL\n  uBit.serial.setBaud(rate);\n#else\n  uBit.serial.baud((int)rate);\n#endif\n  create_fiber(startMbitMoreSerialReceiving);\n}\n\nvoid MbitMoreSerial::readResponseOnSerial(uint16_t ch, uint8_t *dataBuffer, size_t len) {\n  size_t frameSize = 6 + len;\n  uint8_t frame[frameSize] = {0};\n  frame[0] = MM_SFD;\n  frame[1] = ChResponse::RES_READ;\n  frame[2] = ch >> 8;\n  frame[3] = ch & 0x00FF;\n  frame[4] = len;\n  memcpy(&frame[5], dataBuffer, len);\n  frame[frameSize - 1] = chksum8(frame, frameSize - 1);\n  while ((MM_TX_BUFFER_SIZE - uBit.serial.txBufferedSize()) < (int)frameSize) {\n    fiber_sleep(1);\n  }\n  uBit.serial.send(frame, frameSize, ASYNC);\n}\n\nvoid MbitMoreSerial::writeResponseOnSerial(uint16_t ch, bool response) {\n  uint8_t frame[7] = {0};\n  frame[0] = MM_SFD;\n  frame[1] = ChResponse::RES_WRITE;\n  frame[2] = ch >> 8;\n  frame[3] = ch & 0x00FF;\n  frame[4] = 1;\n  frame[5] = 1;\n  frame[6] = chksum8(frame, 6);\n  while ((MM_TX_BUFFER_SIZE - uBit.serial.txBufferedSize()) < 7) {\n    fiber_sleep(1);\n  }\n  uBit.serial.send(frame, 7, SYNC_SLEEP);\n}\n\nvoid MbitMoreSerial::notifyOnSerial(uint16_t ch, uint8_t *dataBuffer, size_t len) {\n  size_t frameSize = 6 + len;\n  uint8_t frame[frameSize] = {0};\n  frame[0] = MM_SFD;\n  frame[1] = ChResponse::RES_NOTIFY;\n  frame[2] = ch >> 8;\n  frame[3] = ch & 0x00FF;\n  frame[4] = len;\n  memcpy(&frame[5], dataBuffer, len);\n  frame[frameSize - 1] = chksum8(frame, frameSize - 1);\n  while ((MM_TX_BUFFER_SIZE - uBit.serial.txBufferedSize()) < (int)frameSize) {\n    fiber_sleep(1);\n  }\n  uBit.serial.send(frame, frameSize, ASYNC);\n}\n\nvoid MbitMoreSerial::startSerialUpdating() {\n  MbitMoreService *moreService = mbitMore.moreService;\n  uint16_t stateCh = 0x0101;\n  uint16_t motionCh = 0x0102;\n  while (true) {\n    if (uBit.serial.txBufferedSize() < 100) {\n      mbitMore.updateState(moreService->stateChBuffer);\n      readResponseOnSerial(stateCh, moreService->stateChBuffer, MM_CH_BUFFER_SIZE_STATE);\n      fiber_sleep(20);\n      mbitMore.updateMotion(moreService->motionChBuffer);\n      readResponseOnSerial(motionCh, moreService->motionChBuffer, MM_CH_BUFFER_SIZE_MOTION);\n      fiber_sleep(20);\n    }\n  }\n}\n\nvoid MbitMoreSerial::startSerialReceiving() {\n  MbitMoreService *moreService = mbitMore.moreService;\n  int requestType;\n  uint16_t ch;\n  uint8_t *responseBuffer;\n\n  uBit.serial.setTxBufferSize(MM_TX_BUFFER_SIZE);\n  uBit.serial.clearTxBuffer();\n  uBit.serial.setRxBufferSize(MM_RX_BUFFER_SIZE);\n  uBit.serial.clearRxBuffer();\n\n  uint8_t frame[26] = {0};\n  size_t frameReceived = 0;\n\n  while (true) {\n    while ((frameReceived > 0) && (MM_SFD != frame[0])) {\n      frameReceived--;\n      memmove(frame, frame + 1, frameReceived);\n    }\n    if (frameReceived == 0) {\n      frame[0] = readSync();\n      if (MM_SFD != frame[0]) {\n        continue;\n      }\n      frameReceived = 1;\n    }\n    if (frameReceived == 1) {\n      frame[1] = readSync();\n      frameReceived = 2;\n    }\n    requestType = frame[1];\n    if (requestType < 0 || requestType > ChRequest::REQ_NOTIFY_START) {\n      frameReceived--;\n      memmove(frame, frame + 1, frameReceived);\n      continue; // reset frame reading\n    }\n    if (frameReceived == 2) {\n      frame[2] = readSync();\n      frameReceived = 3;\n    }\n    if (frameReceived == 3) {\n      frame[3] = readSync();\n      frameReceived = 4;\n    }\n    ch = frame[2] << 8;\n    ch |= frame[3];\n    // COMMAND\n    if (0x0100 == ch) {\n      if (ChRequest::REQ_READ == requestType) {\n        // Start connection\n        mbitMore.updateVersionData();\n        responseBuffer = moreService->commandChBuffer;\n        responseBuffer[2] = MbitMoreCommunicationRoute::SERIAL;\n        readResponseOnSerial(ch, responseBuffer, MM_CH_BUFFER_SIZE_COMMAND);\n        if (!mbitMore.serialConnected) {\n          mbitMore.onSerialConnected();\n          create_fiber(startMbitMoreSerialUpdating);\n        }\n        frameReceived = 0; // reset frame reading\n        continue;\n      }\n      if (ChRequest::REQ_WRITE == requestType || ChRequest::REQ_WRITE_RESPONSE == requestType) {\n        if (frameReceived == 4) {\n          frame[4] = readSync();\n          frameReceived = 5;\n        }\n        uint8_t commandLength = frame[4];\n        if (commandLength > 20) {\n          frameReceived--;\n          memmove(frame, frame + 1, frameReceived);\n          continue;\n        }\n        size_t frameSize = 5 + commandLength + 1;\n        for (size_t i = frameReceived; i < frameSize; i++) {\n          frame[i] = readSync();\n          frameReceived = i + 1;\n        }\n        if (chksum8(frame, 5 + commandLength) != frame[frameSize - 1]) {\n          frameReceived--;\n          memmove(frame, frame + 1, frameReceived);\n          continue;\n        }\n        memcpy(moreService->commandChBuffer, &frame[5], commandLength);\n        mbitMore.onCommandReceived(moreService->commandChBuffer, commandLength);\n        if (ChRequest::REQ_WRITE_RESPONSE == requestType) {\n          writeResponseOnSerial(ch, true);\n        }\n        frameReceived = 0; // reset frame reading\n        continue;\n      }\n    }\n\n    // State\n    if (0x0101 == ch) {\n      if (ChRequest::REQ_READ == requestType) {\n        mbitMore.updateState(moreService->stateChBuffer);\n        readResponseOnSerial(0x0101, moreService->stateChBuffer, MM_CH_BUFFER_SIZE_STATE);\n        frameReceived = 0; // reset frame reading\n        continue;\n      }\n    }\n\n    // Motion\n    if (0x0102 == ch) {\n      if (ChRequest::REQ_READ == requestType) {\n        mbitMore.updateMotion(moreService->motionChBuffer);\n        readResponseOnSerial(0x0102, moreService->motionChBuffer, MM_CH_BUFFER_SIZE_MOTION);\n        frameReceived = 0; // reset frame reading\n        continue;\n      }\n    }\n\n    // ANALOG_IN_P0\n    if (0x0120 == ch) {\n      if (ChRequest::REQ_READ == requestType) {\n        mbitMore.updateAnalogIn(moreService->analogInP0ChBuffer, 0);\n        readResponseOnSerial(ch, moreService->analogInP0ChBuffer, MM_CH_BUFFER_SIZE_ANALOG_IN);\n        frameReceived = 0; // reset frame reading\n        continue;\n      }\n    }\n\n    // ANALOG_IN_P1\n    if (0x0121 == ch) {\n      if (ChRequest::REQ_READ == requestType) {\n        mbitMore.updateAnalogIn(moreService->analogInP1ChBuffer, 1);\n        readResponseOnSerial(ch, moreService->analogInP1ChBuffer, MM_CH_BUFFER_SIZE_ANALOG_IN);\n        frameReceived = 0; // reset frame reading\n        continue;\n      }\n    }\n\n    // ANALOG_IN_P2\n    if (0x0122 == ch) {\n      if (ChRequest::REQ_READ == requestType) {\n        mbitMore.updateAnalogIn(moreService->analogInP2ChBuffer, 2);\n        readResponseOnSerial(ch, moreService->analogInP2ChBuffer, MM_CH_BUFFER_SIZE_ANALOG_IN);\n        frameReceived = 0; // reset frame reading\n        continue;\n      }\n    }\n\n    // Not matched\n    frameReceived--;\n    memmove(frame, frame + 1, frameReceived);\n  }\n}\n\n#endif // MBIT_MORE_USE_SERIAL","MbitMoreSerial.h":"#include \"MbitMoreCommon.h\"\n#if MBIT_MORE_USE_SERIAL\n\n#ifndef MBIT_MORE_SERIAL_H\n#define MBIT_MORE_SERIAL_H\n\n#include \"MbitMoreDevice.h\"\n\n#define MM_SFD 0xff\n#define MM_RX_BUFFER_SIZE 254\n#define MM_TX_BUFFER_SIZE 254\n\n// // Forward declaration\nclass MbitMoreDevice;\n\n/**\n * Class definition for main logics of Microbit More Service except bluetooth connectivity.\n *\n */\nclass MbitMoreSerial {\nprivate:\n  /**\n   * @brief Communication route between Scratch and micro:bit\n   * \n   */\n  enum MbitMoreCommunicationRoute\n  {\n    BLE = 0,\n    SERIAL = 1,\n  };\n\n  /**\n   * @brief Request type from Scratch\n   * \n   */\n  enum ChRequest\n  {\n    REQ_READ = 0x01,\n    REQ_WRITE = 0x10,\n    REQ_WRITE_RESPONSE = 0x11,\n    REQ_NOTIFY_STOP = 0x20,\n    REQ_NOTIFY_START = 0x21,\n  };\n\n  /**\n   * @brief Response type to Scratch\n   * \n   */\n  enum ChResponse\n  {\n    RES_READ = 0x01,\n    RES_WRITE = 0x11,\n    RES_NOTIFY = 0x21,\n  };\n\npublic:\n  /**\n   * @brief Microbit More object.\n   *\n   */\n  MbitMoreDevice &mbitMore;\n\n  /**\n   * @brief Construct a new Microbit More Serial service\n   * \n   * @param _mbitMore An instance of Microbit More device controller\n   */\n  MbitMoreSerial(MbitMoreDevice &_mbitMore);\n\n  /**\n   * @brief Send a response for read request.\n   * \n   * @param ch Characteristeic of the request\n   * @param dataBuffer Buffer to send\n   * @param len Length of the buffer to send\n   */\n  void readResponseOnSerial(uint16_t ch, uint8_t *dataBuffer, size_t len);\n\n  /**\n   * @brief Send a response for write request.\n   * \n   * @param ch Characteristic of the request\n   * @param response Response for the request\n   */\n  void writeResponseOnSerial(uint16_t ch, bool response);\n\n  /**\n   * @brief Notify data of the characteristic\n   * \n   * @param ch Characteristic to notify\n   * @param dataBuffer Buffer to notify\n   * @param len Length of the buffer to notify\n   */\n  void notifyOnSerial(uint16_t ch, uint8_t *dataBuffer, size_t len);\n\n  /**\n   * @brief Start continuous receiving process from serial port.\n   * \n   */\n  void startSerialReceiving();\n\n  /**\n   * @brief Start continuous updating process to serial port.\n   * \n   */\n  void startSerialUpdating();\n};\n#endif // MBIT_MORE_SERIAL_H\n#endif // MBIT_MORE_USE_SERIAL","MbitMoreService.cpp":"#include \"pxt.h\"\n\n#if MICROBIT_CODAL\n\n#include \"nrf_saadc.h\"\n\n/**\n * Class definition for the Scratch3 MicrobitMore Service.\n * Provides a BLE service to Scratch3.\n */\n#include \"MicroBitConfig.h\"\n\n#if CONFIG_ENABLED(DEVICE_BLE)\n\n// #include \"ble_advdata.h\"\n\n#include \"MbitMoreService.h\"\n#include \"MicroBitButton.h\"\n\n// service ID: 0b50f3e4-607f-4151-9091-7d008d6ffc5c\nconst uint8_t MbitMoreService::baseUUID[16] = {0x0b, 0x50, 0xf3, 0xe4, 0x60, 0x7f, 0x41, 0x51, 0x90, 0x91, 0x7d, 0x00, 0x8d, 0x6f, 0xfc, 0x5c};\nconst uint16_t MbitMoreService::serviceUUID = 0xf3e4;\nconst uint16_t MbitMoreService::charUUID[mbitmore_cIdx_COUNT] = {\n    0x0100, // COMMAND\n    0x0101, // STATE\n    0x0102, // MOTION\n    0x0110, // PIN_EVENT\n    0x0111, // ACTION_EVENT\n    0x0120, // ANALOG_IN_P0\n    0x0121, // ANALOG_IN_P1\n    0x0122, // ANALOG_IN_P2\n    0x0130  // MESSAGE\n};\n\n/**\n * Constructor.\n * Create a representation of default extension for Scratch3.\n */\nMbitMoreService::MbitMoreService() : uBit(pxt::uBit) {\n  mbitMore = &MbitMoreDevice::getInstance();\n  mbitMore->moreService = this;\n\n  // Create the service.\n  bs_uuid_type = BLE_UUID_TYPE_UNKNOWN;\n  RegisterBaseUUID(baseUUID);\n  CreateService(serviceUUID);\n\n  // Add each of our characteristics.\n  CreateCharacteristic(\n      mbitmore_cIdx_COMMAND,\n      charUUID[mbitmore_cIdx_COMMAND],\n      (uint8_t *)(commandChBuffer),\n      MM_CH_BUFFER_SIZE_COMMAND,\n      MM_CH_BUFFER_SIZE_COMMAND,\n      microbit_propWRITE | microbit_propWRITE_WITHOUT | microbit_propREAD);\n\n  CreateCharacteristic(\n      mbitmore_cIdx_STATE,\n      charUUID[mbitmore_cIdx_STATE],\n      (uint8_t *)(stateChBuffer),\n      MM_CH_BUFFER_SIZE_STATE,\n      MM_CH_BUFFER_SIZE_STATE,\n      microbit_propREAD);\n\n  CreateCharacteristic(\n      mbitmore_cIdx_MOTION,\n      charUUID[mbitmore_cIdx_MOTION],\n      (uint8_t *)(motionChBuffer),\n      MM_CH_BUFFER_SIZE_MOTION,\n      MM_CH_BUFFER_SIZE_MOTION,\n      microbit_propREAD);\n\n  CreateCharacteristic(\n      mbitmore_cIdx_PIN_EVENT,\n      charUUID[mbitmore_cIdx_PIN_EVENT],\n      (uint8_t *)(pinEventChBuffer),\n      MM_CH_BUFFER_SIZE_NOTIFY,\n      MM_CH_BUFFER_SIZE_NOTIFY,\n      microbit_propREAD | microbit_propNOTIFY);\n\n  CreateCharacteristic(\n      mbitmore_cIdx_ACTION_EVENT,\n      charUUID[mbitmore_cIdx_ACTION_EVENT],\n      (uint8_t *)(actionEventChBuffer),\n      MM_CH_BUFFER_SIZE_NOTIFY,\n      MM_CH_BUFFER_SIZE_NOTIFY,\n      microbit_propREAD | microbit_propNOTIFY);\n\n  CreateCharacteristic(\n      mbitmore_cIdx_ANALOG_IN_P0,\n      charUUID[mbitmore_cIdx_ANALOG_IN_P0],\n      (uint8_t *)(analogInP0ChBuffer),\n      MM_CH_BUFFER_SIZE_ANALOG_IN,\n      MM_CH_BUFFER_SIZE_ANALOG_IN,\n      microbit_propREAD | microbit_propREADAUTH);\n\n  CreateCharacteristic(\n      mbitmore_cIdx_ANALOG_IN_P1,\n      charUUID[mbitmore_cIdx_ANALOG_IN_P1],\n      (uint8_t *)(analogInP1ChBuffer),\n      MM_CH_BUFFER_SIZE_ANALOG_IN,\n      MM_CH_BUFFER_SIZE_ANALOG_IN,\n      microbit_propREAD | microbit_propREADAUTH);\n\n  CreateCharacteristic(\n      mbitmore_cIdx_ANALOG_IN_P2,\n      charUUID[mbitmore_cIdx_ANALOG_IN_P2],\n      (uint8_t *)(analogInP2ChBuffer),\n      MM_CH_BUFFER_SIZE_ANALOG_IN,\n      MM_CH_BUFFER_SIZE_ANALOG_IN,\n      microbit_propREAD | microbit_propREADAUTH);\n\n  CreateCharacteristic(\n      mbitmore_cIdx_DATA,\n      charUUID[mbitmore_cIdx_DATA],\n      (uint8_t *)(dataChBuffer),\n      MM_CH_BUFFER_SIZE_NOTIFY,\n      MM_CH_BUFFER_SIZE_NOTIFY,\n      microbit_propREAD | microbit_propNOTIFY);\n\n  // // Stop advertising.\n  // uBit.ble->stopAdvertising();\n\n  // // Configure advertising.\n  // ble_uuid_t adv_uuids[] = {{serviceUUID, BLE_UUID_TYPE_BLE}};\n  // ble_advdata_t advdata;\n  // memset(&advdata, 0, sizeof(advdata));\n  // advdata.name_type = BLE_ADVDATA_FULL_NAME;\n  // advdata.include_appearance = true;\n  // advdata.flags = BLE_GAP_ADV_FLAGS_LE_ONLY_GENERAL_DISC_MODE;\n  // advdata.uuids_complete.uuid_cnt = sizeof(adv_uuids) / sizeof(adv_uuids[0]);\n  // advdata.uuids_complete.p_uuids = adv_uuids;\n  // bool connectable = true;\n  // bool discoverable = true;\n  // bool whitelist = false;\n  // uBit.ble->configureAdvertising(connectable, discoverable, whitelist,\n  //                                MICROBIT_BLE_ADVERTISING_INTERVAL,\n  //                                MICROBIT_BLE_ADVERTISING_TIMEOUT, &advdata);\n\n  // // Start advertising.\n  // uBit.ble->advertise();\n\n  fiber_add_idle_component(this);\n}\n\n/**\n * Invoked when BLE connects.\n */\nvoid MbitMoreService::onConnect(const microbit_ble_evt_t *p_ble_evt) {\n  mbitMore->updateVersionData();\n}\n\n/**\n * Invoked when BLE disconnects.\n */\nvoid MbitMoreService::onDisconnect(const microbit_ble_evt_t *p_ble_evt) {\n}\n\n/**\n * Callback. Invoked when any of our attributes are written via BLE.\n */\nvoid MbitMoreService::onDataWritten(const microbit_ble_evt_write_t *params) {\n  if (params->handle == valueHandle(mbitmore_cIdx_COMMAND) && params->len > 0) {\n    mbitMore->onCommandReceived((uint8_t *)params->data, params->len);\n  }\n}\n\n/**\n * Callback. Invoked when any of our attributes are read via BLE.\n * Set  params->data and params->length to update the value\n */\nvoid MbitMoreService::onDataRead(microbit_onDataRead_t *params) {\n  if (params->handle == valueHandle(mbitmore_cIdx_ANALOG_IN_P0)) {\n    mbitMore->updateAnalogIn(analogInP0ChBuffer, 0);\n    params->data = analogInP0ChBuffer;\n    params->length = 2;\n  } else if (params->handle == valueHandle(mbitmore_cIdx_ANALOG_IN_P1)) {\n    mbitMore->updateAnalogIn(analogInP1ChBuffer, 1);\n    params->data = analogInP1ChBuffer;\n    params->length = 2;\n  } else if (params->handle == valueHandle(mbitmore_cIdx_ANALOG_IN_P2)) {\n    mbitMore->updateAnalogIn(analogInP2ChBuffer, 2);\n    params->data = analogInP2ChBuffer;\n    params->length = 2;\n  }\n}\n\n/**\n * Periodic callback from MicroBit idle thread.\n */\nvoid MbitMoreService::idleCallback() {\n  if (getConnected()) {\n  } else {\n    mbitMore->displayFriendlyName();\n  }\n}\n\n/**\n * @brief Notify action event.\n */\nvoid MbitMoreService::notifyActionEvent() {\n  if (!getConnected())\n    return;\n  notifyChrValue(mbitmore_cIdx_ACTION_EVENT, actionEventChBuffer,\n                 MM_CH_BUFFER_SIZE_NOTIFY);\n}\n\n/**\n * @brief Notify pin event.\n */\nvoid MbitMoreService::notifyPinEvent() {\n  if (!getConnected())\n    return;\n  notifyChrValue(mbitmore_cIdx_PIN_EVENT, pinEventChBuffer,\n                 MM_CH_BUFFER_SIZE_NOTIFY);\n}\n\n/**\n * Notify message to Scratch3\n */\nvoid MbitMoreService::notifyData() {\n  if (!getConnected())\n    return;\n  notifyChrValue(mbitmore_cIdx_DATA, dataChBuffer, MM_CH_BUFFER_SIZE_NOTIFY);\n}\n\n/**\n * Notify data to Scratch3\n */\nvoid MbitMoreService::notify() {}\n\n/**\n * Update all sensors.\n */\nvoid MbitMoreService::update() {\n  if (getConnected()) {\n    mbitMore->updateState(stateChBuffer);\n    mbitMore->updateMotion(motionChBuffer);\n  }\n}\n\n/**\n * @brief Register data label and retrun ID for the label.\n *\n * @param dataLabel label to register\n * @param dataType type of the data to be received\n * @return int ID for the label\n */\nint MbitMoreService::registerWaitingDataLabel(ManagedString dataLabel, MbitMoreDataContentType dataType) {\n  return mbitMore->registerWaitingDataLabel(dataLabel, dataType);\n}\n\n/**\n * @brief Get type of content for the label\n *\n * @param labelID ID for the label\n * @return type of content [number | string]\n */\nMbitMoreDataContentType MbitMoreService::dataType(int labelID) {\n  return mbitMore->dataType(labelID);\n}\n\n/**\n * @brief Return content of the data as number\n *\n * @param labelID ID for the label\n * @return content of the data\n */\nfloat MbitMoreService::dataContentAsNumber(int labelID) {\n  return mbitMore->dataContentAsNumber(labelID);\n}\n\n/**\n * @brief Return content of the data as string\n *\n * @param labelID ID for the label\n * @return content of the data\n */\nManagedString MbitMoreService::dataContentAsText(int labelID) {\n  return mbitMore->dataContentAsText(labelID);\n}\n\n/**\n * @brief Send a float with label to Scratch.\n *  \n * @param dataLabel label of the data\n * @param dataContent content of the data\n */\nvoid MbitMoreService::sendNumberWithLabel(ManagedString dataLabel, float dataContent) {\n  mbitMore->sendNumberWithLabel(dataLabel, dataContent);\n}\n\n/**\n * @brief Send a string with label to Scratch.\n * \n * @param dataLabel label of the data\n * @param dataContent content of the data\n */\nvoid MbitMoreService::sendTextWithLabel(ManagedString dataLabel, ManagedString dataContent) {\n  mbitMore->sendTextWithLabel(dataLabel, dataContent);\n}\n\n#endif // CONFIG_ENABLED(DEVICE_BLE)\n#endif // MICROBIT_CODAL","MbitMoreService.h":"#include \"pxt.h\"\n\n#if MICROBIT_CODAL\n\n#ifndef MBIT_MORE_SERVICE_H\n#define MBIT_MORE_SERVICE_H\n\n#include \"MicroBitConfig.h\"\n\n#if CONFIG_ENABLED(DEVICE_BLE)\n\n#include \"MicroBit.h\"\n#include \"MicroBitBLEManager.h\"\n#include \"MicroBitBLEService.h\"\n\n#include \"MbitMoreCommon.h\"\n#include \"MbitMoreDevice.h\"\n\n// // Forward declaration\nclass MbitMoreDevice;\n\n/**\n * Class definition for the Scratch basic Service.\n * Provides a BLE service for default extension of micro:bit in Scratch3.\n */\nclass MbitMoreService : public MicroBitBLEService, MicroBitComponent {\npublic:\n  // Buffer of characteristic for receiving commands.\n  uint8_t commandChBuffer[MM_CH_BUFFER_SIZE_COMMAND] = {0};\n\n  // Buffer of characteristic for sending data of GPIO and sensors state.\n  uint8_t stateChBuffer[MM_CH_BUFFER_SIZE_STATE] = {0};\n\n  // Buffer of characteristic for sending data about motion.\n  uint8_t motionChBuffer[MM_CH_BUFFER_SIZE_MOTION] = {0};\n\n  // Buffer of characteristic for sending pin events.\n  uint8_t pinEventChBuffer[MM_CH_BUFFER_SIZE_NOTIFY] = {0};\n\n  // Buffer of characteristic for sending action events.\n  uint8_t actionEventChBuffer[MM_CH_BUFFER_SIZE_NOTIFY] = {0};\n\n  // Buffer of characteristic for sending analog input values of P0.\n  uint8_t analogInP0ChBuffer[MM_CH_BUFFER_SIZE_ANALOG_IN] = {0};\n\n  // Buffer of characteristic for sending analog input values of P1.\n  uint8_t analogInP1ChBuffer[MM_CH_BUFFER_SIZE_ANALOG_IN] = {0};\n\n  // Buffer of characteristic for sending analog input values of P2.\n  uint8_t analogInP2ChBuffer[MM_CH_BUFFER_SIZE_ANALOG_IN] = {0};\n\n  // Buffer of characteristic for sending data.\n  uint8_t dataChBuffer[MM_CH_BUFFER_SIZE_NOTIFY] = {0};\n\n  /**\n   * Constructor.\n   * Create a representation of default extension for Scratch3.\n   */\n  MbitMoreService();\n\n  /**\n   * Invoked when BLE connects.\n   */\n  void onConnect(const microbit_ble_evt_t *p_ble_evt);\n\n  /**\n   * Invoked when BLE disconnects.\n   */\n  void onDisconnect(const microbit_ble_evt_t *p_ble_evt);\n\n  /**\n   * Callback. Invoked when any of our attributes are written via BLE.\n   */\n  void onDataWritten(const microbit_ble_evt_write_t *params);\n\n  /**\n   * Callback. Invoked when any of our attributes are read via BLE.\n   * Set  params->data and params->length to update the value\n   */\n  void onDataRead(microbit_onDataRead_t *params);\n\n  /**\n   * Periodic callback from MicroBit idle thread.\n   */\n  virtual void idleCallback();\n\n  /**\n   * @brief Notify action event.\n   */\n  void notifyActionEvent();\n\n  /**\n   * @brief Notify action event.\n   */\n  void notifyPinEvent();\n\n  /**\n   * @brief Notify sending data to Scratch\n   * \n   */\n  void notifyData();\n\n  void notify();\n\n  void update();\n\n  /**\n   * @brief Register data label and retrun ID for the label.\n   *\n   * @param dataLabel label to register\n   * @param dataType type of the data to be received\n   * @return int ID for the label\n   */\n  int registerWaitingDataLabel(ManagedString dataLabel, MbitMoreDataContentType dataType);\n\n  /**\n   * @brief Get type of content for the label\n   *\n   * @param labelID ID for the label\n   * @return type of content [number | string]\n   */\n  MbitMoreDataContentType dataType(int labelID);\n\n  /**\n   * @brief Return content of the data as number\n   *\n   * @param labelID ID for the label\n   * @return content of the data\n   */\n  float dataContentAsNumber(int labelID);\n\n  /**\n   * @brief Return content of the data as string\n   *\n   * @param labelID ID for the label\n   * @return content of the data\n   */\n  ManagedString dataContentAsText(int labelID);\n\n  /**\n   * @brief Send a float with labele to Scratch.\n   *  \n   * @param dataLabel label of the data\n   * @param dataContent content of the data\n   */\n  void sendNumberWithLabel(ManagedString dataLabel, float dataContent);\n\n  /**\n   * @brief Send a string with labele to Scratch.\n   * \n   * @param dataLabel label of the data\n   * @param dataContent content of the data\n   */\n  void sendTextWithLabel(ManagedString dataLabel, ManagedString dataContent);\n\nprivate:\n  /**\n   * @brief micro:bit runtime object.\n   *\n   */\n  MicroBit &uBit;\n\n  /**\n   * @brief Microbit More object.\n   *\n   */\n  MbitMoreDevice *mbitMore;\n\n  // Index for each charactersitic in arrays of handles and UUIDs\n  typedef enum mbitmore_cIdx\n  {\n    mbitmore_cIdx_COMMAND,\n    mbitmore_cIdx_STATE,\n    mbitmore_cIdx_MOTION,\n    mbitmore_cIdx_PIN_EVENT,\n    mbitmore_cIdx_ACTION_EVENT,\n    mbitmore_cIdx_ANALOG_IN_P0,\n    mbitmore_cIdx_ANALOG_IN_P1,\n    mbitmore_cIdx_ANALOG_IN_P2,\n    mbitmore_cIdx_DATA,\n    mbitmore_cIdx_COUNT\n  } mbitmore_cIdx;\n\n  // UUIDs for our service and characteristics\n  static const uint8_t baseUUID[16];\n  static const uint16_t serviceUUID;\n  static const uint16_t charUUID[mbitmore_cIdx_COUNT];\n\n  // Data for each characteristic when they are held by Soft Device.\n  MicroBitBLEChar chars[mbitmore_cIdx_COUNT];\n\n  /**\n   * Write IO characteristics.\n   */\n  void writeDigitalIn();\n\npublic:\n  int characteristicCount() { return mbitmore_cIdx_COUNT; };\n  MicroBitBLEChar *characteristicPtr(int idx) { return &chars[idx]; };\n};\n\n#endif // CONFIG_ENABLED(DEVICE_BLE)\n#endif // MBIT_MORE_SERVICE_H\n#endif // MICROBIT_CODAL\n","MbitMoreServiceDAL.cpp":"#include \"pxt.h\"\n\n#include \"MicroBit.h\"\n#include \"MicroBitConfig.h\"\n\n#if !MICROBIT_CODAL\n\n#include \"MicroBitButton.h\"\n\n#include \"MbitMoreServiceDAL.h\"\n\n#define MBIT_MORE_DATA_FORMAT_BUTTON_EVENT 0x11\n\n/**\n * @brief Service ID of Microbit More.\n *\n */\nconst uint8_t MBIT_MORE_SERVICE[] = {0x0b, 0x50, 0xf3, 0xe4, 0x60, 0x7f, 0x41, 0x51, 0x90, 0x91, 0x7d, 0x00, 0x8d, 0x6f, 0xfc, 0x5c};\n\n/**\n * @brief Characteristics in Microbit More Service.\n *\n */\nconst uint8_t MBIT_MORE_CH_COMMAND[] = {0x0b, 0x50, 0x01, 0x00, 0x60, 0x7f, 0x41, 0x51, 0x90, 0x91, 0x7d, 0x00, 0x8d, 0x6f, 0xfc, 0x5c};\nconst uint8_t MBIT_MORE_CH_STATE[] = {0x0b, 0x50, 0x01, 0x01, 0x60, 0x7f, 0x41, 0x51, 0x90, 0x91, 0x7d, 0x00, 0x8d, 0x6f, 0xfc, 0x5c};\nconst uint8_t MBIT_MORE_CH_DIRECTION[] = {0x0b, 0x50, 0x01, 0x02, 0x60, 0x7f, 0x41, 0x51, 0x90, 0x91, 0x7d, 0x00, 0x8d, 0x6f, 0xfc, 0x5c};\nconst uint8_t MBIT_MORE_CH_PIN_EVENT[] = {0x0b, 0x50, 0x01, 0x10, 0x60, 0x7f, 0x41, 0x51, 0x90, 0x91, 0x7d, 0x00, 0x8d, 0x6f, 0xfc, 0x5c};\nconst uint8_t MBIT_MORE_CH_ACTION_EVENT[] = {0x0b, 0x50, 0x01, 0x11, 0x60, 0x7f, 0x41, 0x51, 0x90, 0x91, 0x7d, 0x00, 0x8d, 0x6f, 0xfc, 0x5c};\nconst uint8_t MBIT_MORE_CH_ANALOG_IN_P0[] = {0x0b, 0x50, 0x01, 0x20, 0x60, 0x7f, 0x41, 0x51, 0x90, 0x91, 0x7d, 0x00, 0x8d, 0x6f, 0xfc, 0x5c};\nconst uint8_t MBIT_MORE_CH_ANALOG_IN_P1[] = {0x0b, 0x50, 0x01, 0x21, 0x60, 0x7f, 0x41, 0x51, 0x90, 0x91, 0x7d, 0x00, 0x8d, 0x6f, 0xfc, 0x5c};\nconst uint8_t MBIT_MORE_CH_ANALOG_IN_P2[] = {0x0b, 0x50, 0x01, 0x22, 0x60, 0x7f, 0x41, 0x51, 0x90, 0x91, 0x7d, 0x00, 0x8d, 0x6f, 0xfc, 0x5c};\n\n/**\n * Class definition for the Scratch MicroBit More Service.\n * Provides a BLE service to remotely controll Micro:bit from Scratch3.\n */\n\n/**\n * Constructor.\n * Create a representation of the Microbit More BLE Service\n */\nMbitMoreServiceDAL::MbitMoreServiceDAL() : uBit(pxt::uBit) {\n  mbitMore = &MbitMoreDevice::getInstance();\n  mbitMore->moreService = this;\n\n  commandCh = new GattCharacteristic(\n      MBIT_MORE_CH_COMMAND, commandChBuffer, MM_CH_BUFFER_SIZE_COMMAND, MM_CH_BUFFER_SIZE_COMMAND,\n      GattCharacteristic::BLE_GATT_CHAR_PROPERTIES_WRITE |\n          GattCharacteristic::BLE_GATT_CHAR_PROPERTIES_WRITE_WITHOUT_RESPONSE | GattCharacteristic::BLE_GATT_CHAR_PROPERTIES_READ);\n  commandCh->requireSecurity(SecurityManager::MICROBIT_BLE_SECURITY_LEVEL);\n\n  stateCh = new GattCharacteristic(\n      MBIT_MORE_CH_STATE, (uint8_t *)&stateChBuffer,\n      MM_CH_BUFFER_SIZE_STATE, MM_CH_BUFFER_SIZE_STATE,\n      GattCharacteristic::BLE_GATT_CHAR_PROPERTIES_READ);\n  stateCh->requireSecurity(SecurityManager::MICROBIT_BLE_SECURITY_LEVEL);\n\n  directionCh = new GattCharacteristic(\n      MBIT_MORE_CH_DIRECTION, (uint8_t *)&motionChBuffer,\n      MM_CH_BUFFER_SIZE_MOTION, MM_CH_BUFFER_SIZE_MOTION,\n      GattCharacteristic::BLE_GATT_CHAR_PROPERTIES_READ);\n  directionCh->requireSecurity(SecurityManager::MICROBIT_BLE_SECURITY_LEVEL);\n\n  pinEventCh = new GattCharacteristic(\n      MBIT_MORE_CH_PIN_EVENT, (uint8_t *)&pinEventChBuffer,\n      MM_CH_BUFFER_SIZE_NOTIFY, MM_CH_BUFFER_SIZE_NOTIFY,\n      GattCharacteristic::BLE_GATT_CHAR_PROPERTIES_READ |\n          GattCharacteristic::BLE_GATT_CHAR_PROPERTIES_NOTIFY);\n  pinEventCh->requireSecurity(SecurityManager::MICROBIT_BLE_SECURITY_LEVEL);\n\n  actionEventCh = new GattCharacteristic(\n      MBIT_MORE_CH_ACTION_EVENT, (uint8_t *)&actionEventChBuffer,\n      MM_CH_BUFFER_SIZE_NOTIFY, MM_CH_BUFFER_SIZE_NOTIFY,\n      GattCharacteristic::BLE_GATT_CHAR_PROPERTIES_READ |\n          GattCharacteristic::BLE_GATT_CHAR_PROPERTIES_NOTIFY);\n  actionEventCh->requireSecurity(SecurityManager::MICROBIT_BLE_SECURITY_LEVEL);\n\n  analogInP0Ch = new GattCharacteristic(\n      MBIT_MORE_CH_ANALOG_IN_P0, (uint8_t *)&analogInP0ChBuffer,\n      MM_CH_BUFFER_SIZE_ANALOG_IN, MM_CH_BUFFER_SIZE_ANALOG_IN,\n      GattCharacteristic::BLE_GATT_CHAR_PROPERTIES_READ);\n  analogInP0Ch->setReadAuthorizationCallback(\n      this, &MbitMoreServiceDAL::onReadAnalogIn);\n  analogInP0Ch->requireSecurity(SecurityManager::MICROBIT_BLE_SECURITY_LEVEL);\n\n  analogInP1Ch = new GattCharacteristic(\n      MBIT_MORE_CH_ANALOG_IN_P1, (uint8_t *)&analogInP1ChBuffer,\n      MM_CH_BUFFER_SIZE_ANALOG_IN, MM_CH_BUFFER_SIZE_ANALOG_IN,\n      GattCharacteristic::BLE_GATT_CHAR_PROPERTIES_READ);\n  analogInP1Ch->setReadAuthorizationCallback(\n      this, &MbitMoreServiceDAL::onReadAnalogIn);\n  analogInP1Ch->requireSecurity(SecurityManager::MICROBIT_BLE_SECURITY_LEVEL);\n\n  analogInP2Ch = new GattCharacteristic(\n      MBIT_MORE_CH_ANALOG_IN_P2, (uint8_t *)&analogInP2ChBuffer,\n      MM_CH_BUFFER_SIZE_ANALOG_IN, MM_CH_BUFFER_SIZE_ANALOG_IN,\n      GattCharacteristic::BLE_GATT_CHAR_PROPERTIES_READ);\n  analogInP2Ch->setReadAuthorizationCallback(\n      this, &MbitMoreServiceDAL::onReadAnalogIn);\n  analogInP2Ch->requireSecurity(SecurityManager::MICROBIT_BLE_SECURITY_LEVEL);\n\n  /*\n  stateCh = digitalIn[4], lightLevel[1], temperature[1], microphone[1]\n  directionCh = acceleration[10], magnet[8]\n  pinEventCh = pinEvent\n  actionEventCh = buttonEvent, gestureEvent\n  analogInP0Ch, analogInP1Ch, analogInP2Ch\n  */\n\n  GattCharacteristic *mbitMoreChs[] = {\n      commandCh,\n      stateCh,\n      directionCh,\n      pinEventCh,\n      actionEventCh,\n      analogInP0Ch,\n      analogInP1Ch,\n      analogInP2Ch,\n  };\n\n  uBit.messageBus.listen(\n      MICROBIT_ID_BLE,\n      MICROBIT_BLE_EVT_CONNECTED,\n      this,\n      &MbitMoreServiceDAL::onBLEConnected,\n      MESSAGE_BUS_LISTENER_QUEUE_IF_BUSY);\n\n  GattService mbitMoreService(MBIT_MORE_SERVICE, mbitMoreChs,\n                              sizeof(mbitMoreChs) /\n                                  sizeof(GattCharacteristic *));\n  uBit.ble->addService(mbitMoreService);\n\n  // Setup callbacks for events.\n  uBit.ble->onDataWritten(this, &MbitMoreServiceDAL::onDataWritten);\n}\n\n/**\n   * Invoked when BLE connected.\n   */\nvoid MbitMoreServiceDAL::onBLEConnected(MicroBitEvent _e) {\n  mbitMore->updateVersionData();\n  uBit.ble->gattServer().write(commandCh->getValueHandle(), commandChBuffer,\n                               MM_CH_BUFFER_SIZE_COMMAND);\n}\n\n/**\n * Callback. Invoked when AnalogIn is read via BLE.\n */\nvoid MbitMoreServiceDAL::onReadAnalogIn(\n    GattReadAuthCallbackParams *authParams) {\n  if (authParams->handle == analogInP0Ch->getValueHandle()) {\n    mbitMore->updateAnalogIn(analogInP0ChBuffer, 0);\n    authParams->data = (uint8_t *)&analogInP0ChBuffer;\n    authParams->offset = 0;\n    authParams->len = MM_CH_BUFFER_SIZE_ANALOG_IN;\n    authParams->authorizationReply = AUTH_CALLBACK_REPLY_SUCCESS;\n  } else if (authParams->handle == analogInP1Ch->getValueHandle()) {\n    mbitMore->updateAnalogIn(analogInP1ChBuffer, 1);\n    authParams->data = (uint8_t *)&analogInP1ChBuffer;\n    authParams->offset = 0;\n    authParams->len = MM_CH_BUFFER_SIZE_ANALOG_IN;\n    authParams->authorizationReply = AUTH_CALLBACK_REPLY_SUCCESS;\n  } else if (authParams->handle == analogInP2Ch->getValueHandle()) {\n    mbitMore->updateAnalogIn(analogInP2ChBuffer, 2);\n    authParams->data = (uint8_t *)&analogInP2ChBuffer;\n    authParams->offset = 0;\n    authParams->len = MM_CH_BUFFER_SIZE_ANALOG_IN;\n    authParams->authorizationReply = AUTH_CALLBACK_REPLY_SUCCESS;\n  }\n}\n\n/**\n * Callback. Invoked when any of our attributes are written via BLE.\n */\nvoid MbitMoreServiceDAL::onDataWritten(const GattWriteCallbackParams *params) {\n  mbitMore->onCommandReceived((uint8_t *)params->data, params->len);\n}\n\n/**\n * @brief Notify action event.\n */\nvoid MbitMoreServiceDAL::notifyActionEvent() {\n  uBit.ble->gattServer().notify(actionEventCh->getValueHandle(),\n                                actionEventChBuffer, MM_CH_BUFFER_SIZE_NOTIFY);\n}\n\n/**\n * @brief Notify pin event.\n */\nvoid MbitMoreServiceDAL::notifyPinEvent() {\n  uBit.ble->gattServer().notify(pinEventCh->getValueHandle(), pinEventChBuffer,\n                                MM_CH_BUFFER_SIZE_NOTIFY);\n}\n\n/**\n * Notify data to Scratch3\n */\nvoid MbitMoreServiceDAL::notify() {}\n\n/**\n * Update all GPIO and sensors state.\n */\nvoid MbitMoreServiceDAL::update() {\n  if (uBit.ble->gap().getState().connected) {\n    mbitMore->updateState(stateChBuffer);\n    uBit.ble->gattServer().write(stateCh->getValueHandle(), stateChBuffer,\n                                 MM_CH_BUFFER_SIZE_STATE);\n    mbitMore->updateMotion(motionChBuffer);\n    uBit.ble->gattServer().write(directionCh->getValueHandle(),\n                                 motionChBuffer,\n                                 MM_CH_BUFFER_SIZE_MOTION);\n  } else {\n    mbitMore->displayFriendlyName();\n  }\n}\n\n#endif // !MICROBIT_CODAL\n","MbitMoreServiceDAL.h":"#include \"pxt.h\"\n\n#include \"MicroBit.h\"\n#include \"MicroBitConfig.h\"\n\n#if !MICROBIT_CODAL\n\n#ifndef MBIT_MORE_SERVICE_DAL_H\n#define MBIT_MORE_SERVICE_DAL_H\n\n#include \"MbitMoreCommon.h\"\n#include \"MbitMoreDevice.h\"\n\n// // Forward declaration\nclass MbitMoreDevice;\n\n/**\n * Class definition for a MicroBitMore Service.\n * Provides a BLE service to remotely read the state of sensors from Scratch3.\n */\nclass MbitMoreServiceDAL {\npublic:\n  /**\n   * Constructor.\n   * Create a representation of the MbitMoreService\n   */\n  MbitMoreServiceDAL();\n\n  /**\n   * Invoked when BLE connected.\n   */\n  void onBLEConnected(MicroBitEvent _e);\n\n  void notify();\n\n  /**\n   * @brief Notify action event.\n   */\n  void notifyActionEvent();\n\n  /**\n   * @brief Notify action event.\n   */\n  void notifyPinEvent();\n\n  /**\n   * Callback. Invoked when AnalogIn is read via BLE.\n   */\n  void onReadAnalogIn(GattReadAuthCallbackParams *authParams);\n\n  /**\n   * Callback. Invoked when any of our attributes are written via BLE.\n   */\n  void onDataWritten(const GattWriteCallbackParams *params);\n\n  void update();\n\n  // Buffer of characteristic for receiving commands.\n  uint8_t commandChBuffer[MM_CH_BUFFER_SIZE_COMMAND] = {0};\n\n  // Buffer of characteristic for sending data of GPIO and sensors state.\n  uint8_t stateChBuffer[MM_CH_BUFFER_SIZE_STATE] = {0};\n\n  // Buffer of characteristic for sending data about motion.\n  uint8_t motionChBuffer[MM_CH_BUFFER_SIZE_MOTION] = {0};\n\n  // Buffer of characteristic for sending pin events.\n  uint8_t pinEventChBuffer[MM_CH_BUFFER_SIZE_NOTIFY] = {0};\n\n  // Buffer of characteristic for sending action events.\n  uint8_t actionEventChBuffer[MM_CH_BUFFER_SIZE_NOTIFY] = {0};\n\n  // Buffer of characteristic for sending analog input values of P0.\n  uint8_t analogInP0ChBuffer[MM_CH_BUFFER_SIZE_ANALOG_IN] = {0};\n\n  // Buffer of characteristic for sending analog input values of P1.\n  uint8_t analogInP1ChBuffer[MM_CH_BUFFER_SIZE_ANALOG_IN] = {0};\n\n  // Buffer of characteristic for sending analog input values of P2.\n  uint8_t analogInP2ChBuffer[MM_CH_BUFFER_SIZE_ANALOG_IN] = {0};\n\nprivate:\n  /**\n   * @brief micro:bit runtime object.\n   *\n   */\n  MicroBit &uBit;\n\n  /**\n   * @brief Microbit More object.\n   *\n   */\n  MbitMoreDevice *mbitMore;\n\n  GattCharacteristic *commandCh;\n  GattCharacteristic *stateCh;\n  GattCharacteristic *directionCh;\n  GattCharacteristic *pinEventCh;\n  GattCharacteristic *actionEventCh;\n  GattCharacteristic *analogInP0Ch;\n  GattCharacteristic *analogInP1Ch;\n  GattCharacteristic *analogInP2Ch;\n};\n\n#endif // MBIT_MORE_SERVICE_DAL_H\n#endif // !MICROBIT_CODAL\n","README.md":"\n# Microbit More v2 MakeCode Extension\n\nThis is a MakeCode extension for [Microbit More v2](https://microbit-more.github.io/).\n\n## Use as Extension\n\nThis repository can be added as an **extension** in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **New Project**\n* click on **Extensions** under the gearwheel menu\n* search for **https://github.com/microbit-more/pxt-mbit-more-v2** and import\n* code on the editor\n* click **Download** (which takes about **1 minutes** to compile at first time)\n\n## Edit this project ![Build status badge](https://github.com/microbit-more/pxt-mbit-more-v2/workflows/MakeCode/badge.svg)\n\nTo edit this repository in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **Import** then click on **Import URL**\n* paste **https://github.com/microbit-more/pxt-mbit-more-v2** and click import\n\n## Blocks preview\n\nThis image shows the blocks code from the last commit in master.\nThis image may take a few minutes to refresh.\n\n![A rendered view of the blocks](https://github.com/microbit-more/pxt-mbit-more-v2/raw/master/.github/makecode/blocks.png)\n\n#### Metadata (used for search, rendering)\n\n* for PXT/microbit\n<script src=\"https://makecode.com/gh-pages-embed.js\"></script><script>makeCodeRender(\"{{ site.makecode.home_url }}\", \"{{ site.github.owner_name }}/{{ site.github.repository_name }}\");</script>\n","_locales/en/pxt-mbit-more-v2-strings.json":"{\n  \"MbitMore.onReceivedNumberWithLabel|block\": \"on number $numberData with label $label\",\n  \"MbitMore.onReceivedTextWithLabel|block\": \"on text $textData with label $label\",\n  \"MbitMore.sendNumberWithLabel|block\": \"send number $numberData with label $label\",\n  \"MbitMore.sendTextWithLabel|block\": \"send text $textData with label $label\",\n  \"MbitMore.startService|block\": \"start Microbit More service\",\n  \"MbitMoreDataContentType.MM_DATA_NUMBER|block\": \"number\",\n  \"MbitMoreDataContentType.MM_DATA_TEXT|block\": \"text\",\n  \"MbitMore|block\": \"Microbit More\",\n  \"{id:category}MbitMore\": \"Microbit More\"\n}","_locales/ja/pxt-mbit-more-v2-strings.json":"{\n  \"MbitMore.onReceivedNumberWithLabel|block\": \"ラベル $label の数値 $numberData を受け取ったとき\",\n  \"MbitMore.onReceivedTextWithLabel|block\": \"ラベル $label の文字列 $textData を受け取ったとき\",\n  \"MbitMore.sendNumberWithLabel|block\": \"数値 $numberData にラベル $label を付けて送る\",\n  \"MbitMore.sendTextWithLabel|block\": \"文字列 $textData にラベル $label を付けて送る\",\n  \"MbitMore.startService|block\": \"Microbit Moreサービスを開始する\",\n  \"MbitMoreDataContentType.MM_DATA_NUMBER|block\": \"数値\",\n  \"MbitMoreDataContentType.MM_DATA_TEXT|block\": \"文字列\",\n  \"MbitMore|block\": \"Microbit More\",\n  \"{id:category}MbitMore\": \"Microbit More\"\n}","enums.d.ts":"// Auto-generated. Do not edit.\n\n\n    /**\n     * Data type of content.\n     */\n\n    declare const enum MbitMoreDataContentType\n    {\n    //% block=\"number\"\n    MM_DATA_NUMBER = 1,\n    //% block=\"text\"\n    MM_DATA_TEXT = 2,\n    }\n\n\n    declare const enum MbitMoreCommand\n    {\n    CMD_CONFIG = 0x00,\n    CMD_PIN = 0x01,\n    CMD_DISPLAY = 0x02,\n    CMD_AUDIO = 0x03,\n    CMD_DATA = 0x04,\n    }\n\n\n    declare const enum MbitMorePinCommand\n    {\n    SET_OUTPUT = 0x01,\n    SET_PWM = 0x02,\n    SET_SERVO = 0x03,\n    SET_PULL = 0x04,\n    SET_EVENT = 0x05,\n    }\n\n\n    declare const enum MbitMoreDisplayCommand\n    {\n    CLEAR = 0x00,\n    TEXT = 0x01,\n    PIXELS_0 = 0x02,\n    PIXELS_1 = 0x03,\n    }\n\n\n    /**\n     * @brief Enum for write mode of display pixels.\n     */\n\n    declare const enum MbitMoreDisplayWriteMode\n    {\n    LAYER = 0,\n    OVER_WRITE = 1,\n    }\n\n\n    declare const enum MbitMorePullMode\n    {\n    None = 0,\n    Down = 1,\n    Up = 2,\n    }\n\n\n    declare const enum MbitMoreDataFormat\n    {\n    CONFIG = 0x10,\n    PIN_EVENT = 0x11,\n    ACTION_EVENT = 0x12,\n    DATA_NUMBER = 0x13,\n    DATA_TEXT = 0x14,\n    }\n\n\n    declare const enum MbitMoreActionEvent\n    {\n    BUTTON = 0x01,\n    GESTURE = 0x02,\n    }\n\n\n    declare const enum MbitMoreButtonEvent\n    {\n    DOWN = 1,\n    UP = 2,\n    CLICK = 3,\n    LONG_CLICK = 4,\n    HOLD = 5,\n    DOUBLE_CLICK = 6,\n    }\n\n\n    declare const enum MbitMoreGestureEvent\n    {\n    TILT_UP = 1,\n    TILT_DOWN = 2,\n    TILT_LEFT = 3,\n    TILT_RIGHT = 4,\n    FACE_UP = 5,\n    FACE_DOWN = 6,\n    FREEFALL = 7,\n    G3 = 8,\n    G6 = 9,\n    G8 = 10,\n    SHAKE = 11,\n    }\n\n\n    declare const enum MbitMorePinEventType\n    {\n    NONE = 0,\n    ON_EDGE = 1,\n    ON_PULSE = 2,\n    ON_TOUCH = 3,\n    }\n\n\n    declare const enum MbitMorePinEvent\n    {\n    RISE = 2,\n    FALL = 3,\n    PULSE_HIGH = 4,\n    PULSE_LOW = 5,\n    }\n\n\n    /**\n     * @brief Enum for sub-command about configurations.\n     * \n     */\n\n    declare const enum MbitMoreConfig\n    {\n    MIC = 0x01,\n    TOUCH = 0x02,\n    }\n\n\n    /**\n     * @brief Enum for sub-commands about audio.\n     * \n     */\n\n    declare const enum MbitMoreAudioCommand\n    {\n    STOP_TONE = 0x00,\n    PLAY_TONE = 0x01,\n    }\n\n\n    /**\n     * @brief Button ID in MicrobitMore\n     * This number is used to memory offset in state data.\n     */\n\n    declare const enum MbitMoreButtonStateIndex\n    {\n    // GPIO array using [0..20]\n    P0 = 24,\n    P1 = 25,\n    P2 = 26,\n    A = 27,\n    B = 28,\n    LOGO = 29,\n    }\n\n\n    /**\n     * @brief Version of this micro:bit\n     * \n     */\n\n    declare const enum MbitMoreHardwareVersion\n    {\n    MICROBIT_V1 = 1,\n    MICROBIT_V2 = 2,\n    }\n\n\n    /**\n     * @brief Version of protocol to use\n     * \n     */\n\n    declare const enum MbitMoreProtocol\n    {\n    MBIT_MORE_V2 = 2,\n    }\n\n\n    /**\n     * @brief Communication route between Scratch and micro:bit\n     * \n     */\n\n    declare const enum MbitMoreCommunicationRoute\n    {\n    BLE = 0,\n    SERIAL = 1,\n    }\n\n\n    /**\n     * @brief Request type from Scratch\n     * \n     */\n\n    declare const enum ChRequest\n    {\n    REQ_READ = 0x01,\n    REQ_WRITE = 0x10,\n    REQ_WRITE_RESPONSE = 0x11,\n    REQ_NOTIFY_STOP = 0x20,\n    REQ_NOTIFY_START = 0x21,\n    }\n\n\n    /**\n     * @brief Response type to Scratch\n     * \n     */\n\n    declare const enum ChResponse\n    {\n    RES_READ = 0x01,\n    RES_WRITE = 0x11,\n    RES_NOTIFY = 0x21,\n    }\ndeclare namespace MbitMore {\n}\n\n// Auto-generated. Do not edit. Really.\n","main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables><variable id=\"3wT;^!O~#|M)`dkBKboT\">content</variable></variables><block type=\"pxt-on-start\" id=\"Wr`H!es53`#@WAhCZjVP\" x=\"0\" y=\"0\"><statement name=\"HANDLER\"><block type=\"MbitMore_startMbitMoreService\" id=\"FTW[YIQe.nYvmsTUqScb\"/></statement></block></xml>","main.ts":"MbitMore.startService()\n","pxt.json":"{\n    \"name\": \"pxt-mbit-more-v2\",\n    \"version\": \"0.2.3\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"microphone\": \"*\",\n        \"bluetooth\": \"*\"\n    },\n    \"files\": [\n        \"README.md\",\n        \"main.blocks\",\n        \"main.ts\",\n        \"shims.d.ts\",\n        \"enums.d.ts\",\n        \"MbitMore.cpp\",\n        \"MbitMore.ts\",\n        \"MbitMoreCommon.h\",\n        \"MbitMoreDevice.cpp\",\n        \"MbitMoreDevice.h\",\n        \"MbitMoreSerial.cpp\",\n        \"MbitMoreSerial.h\",\n        \"MbitMoreService.cpp\",\n        \"MbitMoreService.h\",\n        \"MbitMoreServiceDAL.cpp\",\n        \"MbitMoreServiceDAL.h\",\n        \"_locales/en/pxt-mbit-more-v2-strings.json\",\n        \"_locales/ja/pxt-mbit-more-v2-strings.json\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"targetVersions\": {\n        \"branch\": \"v4.0.8\",\n        \"tag\": \"v4.0.8\",\n        \"commits\": \"https://github.com/microsoft/pxt-microbit/commits/d91cb1ff57ecb00f8b739fccb65a500f00bc877b\",\n        \"target\": \"4.0.8\",\n        \"pxt\": \"7.0.5\"\n    },\n    \"supportedTargets\": [\n        \"microbit\"\n    ],\n    \"preferredEditor\": \"blocksprj\",\n    \"yotta\": {\n        \"dependencies\": {\n            \"microbit\": \"yokobond/microbit#mbit-more\"\n        },\n        \"config\": {\n            \"microbit-dal\": {\n                \"bluetooth\": {\n                    \"enabled\": 1,\n                    \"pairing_mode\": 0,\n                    \"private_addressing\": 0,\n                    \"open\": 1,\n                    \"whitelist\": 0,\n                    \"advertising_timeout\": 0,\n                    \"tx_power\": 0,\n                    \"dfu_service\": 0,\n                    \"event_service\": 0,\n                    \"device_info_service\": 0,\n                    \"security_level\": \"SECURITY_MODE_ENCRYPTION_NO_MITM\"\n                },\n                \"gatt_table_size\": \"0x360\"\n            }\n        }\n    }\n}\n","shims.d.ts":"// Auto-generated. Do not edit.\n\n\n\n    //% color=#FF9900 weight=95 icon=\"\\uf1b0\"\ndeclare namespace MbitMore {\n\n    /**\n     * @brief Start Microbit More service.\n     * \n     */\n    //% shim=MbitMore::startMbitMoreService\n    function startMbitMoreService(): void;\n\n    /**\n     * @brief Register a label in waiting data list and return an ID for the label.\n     * This starts Microbit More service if it was not available.\n     * \n     * @param dataLabel label to register\n     * @param dataType type of the data to be received\n     * @return int ID for the label\n     */\n    //% shim=MbitMore::call_registerWaitingDataLabel\n    function call_registerWaitingDataLabel(dataLabel: string, dataType: MbitMoreDataContentType): int32;\n\n    /**\n     * @brief Get number which was received with the label.\n     * \n     * @param labelID ID in registered labels\n     * @return float received data with the label\n     */\n    //% shim=MbitMore::call_dataContentAsNumber\n    function call_dataContentAsNumber(labelID: int32): number;\n\n    /**\n     * @brief Get text which was received with the label.\n     * \n     * @param labelID ID in registered labels\n     * @return String received data with the label\n     */\n    //% shim=MbitMore::call_dataContentAsText\n    function call_dataContentAsText(labelID: int32): string;\n\n    /**\n     * @brief Send a float with labele to Scratch.\n     * Do nothing if Scratch was not connected.\n     * \n     * @param dataLabel - label of the data\n     * @param dataContent - content of the data\n     */\n    //% shim=MbitMore::call_sendNumberWithLabel\n    function call_sendNumberWithLabel(dataLabel: string, dataContent: number): void;\n\n    /**\n     * @brief Send a text with label to Scratch.\n     * Do nothing if Scratch was not connected.\n     * \n     * @param dataLabel - label of the data\n     * @param dataContent - content of the data\n     */\n    //% shim=MbitMore::call_sendTextWithLabel\n    function call_sendTextWithLabel(dataLabel: string, dataContent: string): void;\n}\n\n// Auto-generated. Do not edit. Really.\n","test.ts":"// tests go here; this will not be compiled when this package is used as an extension.\nMbitMore.onReceivedTextWithLabel(\"label-01\", function (content) {\n  MbitMore.sendTextWithLabel(\"label-01\", content);\n  // basic.showString(\"label-01 = T \" + (content))\n})\nMbitMore.onReceivedNumberWithLabel(\"label-01\", function (content) {\n  MbitMore.sendNumberWithLabel(\"label-01\", content);\n  // basic.showString(\"label-01 = N \" + (content))\n})\nMbitMore.startService()\n"}